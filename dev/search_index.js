var documenterSearchIndex = {"docs":
[{"location":"rates/#Estimating-fixation-and-polymorphic-rates-considering-generalized-model-of-selection-and-linkage","page":"Rates","title":"Estimating fixation and polymorphic rates considering generalized model of selection and linkage","text":"","category":"section"},{"location":"rates/","page":"Rates","title":"Rates","text":"Before executing the rate estimation, you need to load Distributed module and add some threads","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"using Distributed\naddprocs(7)","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Then you need to declare the MKtest module in all the threads using @everywhere macro. Otherwise, the MKtest module will perform the estimation just using the main core","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@everywhere using MKtest","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Declare a variable containing some basic information about your model. We used a sample size of 661 to perform later analysis over TGP data. The selected Derived Alleles Counts (DAC) will be used to compute summary statistics and perform ABC inference. It is possible to subset any of the selected DAC values when computing summary statistics.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"adap = MKtest.parameters(n=661,dac=[1,2,4,5,10,20,50,100,200,400,500,661,925,1000])","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Note that adap contains about mutation rate, recombination rates, DFE, BGS and probabilities of fixations. To check all the arguments you can access to the function documentation using @doc MKtest.parameter","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@doc MKtest.parameter\n\n  Mutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. For this reason, adap is the\n  only exported variable. Adap should be change before the perform the analytical approach, in other case, $\\alpha_{(x)}$ will be solve with the default values.\n\n  Parameters\n  ≡≡≡≡≡≡≡≡≡≡≡≡\n\n    •  gam_neg::Int64: Selection coefficient for deleterious alleles\n\n    •  gL::Int64: Selection coefficient for weakly benefical alleles\n\n    •  gH::Int64: Selection coefficient for strongly benefical alleles\n\n    •  al_low::Float64: Proportion of α due to weak selection\n\n    •  al_tot::Float64: α\n\n    •  θ_noncoding::Float64: Mutation rate defining BGS strength\n\n    •  θ_coding::Float64: Mutation rate on coding region\n\n    •  al::Float64: DFE shape parameter\n\n    •  be::Float64: DFE scale parameter\n\n    •  B::Float64: BGS strength\n\n    •  B_bins::Array{Float64,1}: BGS values to simulate\n\n    •  ppos_l::Float64: Fixation probabily of weakly beneficial alleles\n\n    •  ppos_h::Float64: Fixation probabily of strongly beneficial alleles\n\n    •  N::Int64: Population size\n\n    •  n::Int64: Sample size\n\n    •  Lf::Int64: Flanking region length\n\n    •  rho::Float64: Recombination rate\n\n    •  TE::Float64","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"We will estimate the empirical adaptation rate using TGP data using the estimated DFE parameters at Boyko et al (2008). Nonetheless, shape and scale DFE parameter are flexible in our model.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"adap.al = 0.184\nadap.be = abs(0.184/-457)","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Now the variable adap contains sample size, DAC and DFE information. The function MKtest.rates will perform the analytical estimation of N independent models regarding DFE, BGS, mutation rate, and recombination rate. In the following example, we used the function MKtest.rates to input the prior distributions. The function will randomize the input values to solve N independent estimation regarding our model. ","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@doc MKtest.rates\n  Function to solve randomly N scenarios. The function will create N models, defined by\n  MKtest.parameters(), to estimate analytically fixation and polymorphic rates for each\n  model. The rates will be used to compute summary statistics required at ABC. The function\n  output a HDF5 file containing the solved models, the selected DAC and the analytical\n  rates.\n\n  If ρ and/or theta are set to nothing, the function will input random values given the\n  range 0.0005:0.0005:0.01. Otherwise you can fix the values.\n\n  If gL is set to nothing, the function will not account the role of the weakly selected\n  alleles in the estimation.\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •  param::parameters: mutable structure containing the model\n\n    •  gH::Array{Int64,1} : Range of strong selection coefficients\n\n    •  gL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients\n\n    •  gam_neg::Array{Int64,1} : Range of deleterious selection coefficients\n\n    •  theta::Union{Float64,Nothing} : Population-scaled mutation rate on coding region\n\n    •  rho::Union{Float64,Nothing} : Population-scaled recombination rate\n\n    •  iterations::Int64 : Number of solutions\n\n    •  output::String : File to output HDF5 file\n\n  Returns\n  ≡≡≡≡≡≡≡≡≡\n\n    •  Array: summary statistics\n\n    •  Output: HDF5 file containing models solved and rates.\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@time df = MKtest.rates(param = adap,gH=200:2000,gL=1:10,gam_neg=-2000:-200,iterations = 10^5,output=\"analysis/rates.jld2\");","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The function will create a HDF5 file containing the solved models, fixation rates, polymorphic rates, and the selected DAC. This information will be used later to estimate summary statistics.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Note that MKtest.rates is the most resource and time-consuming function. In our case, the function will estimate 10^5 independent models. Each model solves the estimation for all possible BGS values. We used BGS values from 0.1 to 0.999 in 5% increments. In total, the example will produce 3.7 million estimates. We have used a hierarchical data structure (HDF5) to facilitate model parameters and rates storage.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The following example took about 1.5 hours to execute on the hardware described at section Infering the rate and strength of adaptation","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"If you have a system with few resources, it is possible to download pre-computed TGP and DGN data rates. Please go to the next section to continue the inference using the pre-computed rates.","category":"page"},{"location":"analytical/#MKtest-estimation","page":"Analytical estimations","title":"MKtest estimation","text":"","category":"section"},{"location":"analytical/#Solving-\\alpha_{(x)}","page":"Analytical estimations","title":"Solving alpha_(x)","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Our method is based on the analytical solution of alpha_(x) given a genetic scenario. The approach could be extended to any DFE and background selection values to get summary statistics used at ABC methods. This example shows how the asymptotic alpha is affected by linkage and background selection.","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Before start, you need to set up a variable of type MKtest.parameters. It is a Mutable structure containing the parameters required to solve the analytical approach. Any value at MKtest.parameters can be easily changed. Remember you need to define before the execution. Otherwise, alpha_(x) will be solved with default values. To change all the values at once, check the variables at the struct MKtest.parameters to set specific models.","category":"page"},{"location":"analytical/#Load-the-modules","page":"Analytical estimations","title":"Load the modules","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"using MKtest","category":"page"},{"location":"analytical/#Setting-model-parameters-and-convolute-the-binomial-distribution.","page":"Analytical estimations","title":"Setting model parameters and convolute the binomial distribution.","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"We set a global adaptation rate of 0.4 with a contribution of 0.2 regarding weak adaptation. The process is modeled using a selection coefficient of 500, 10 for strongly and weakly beneficial alleles. We modeled the DFE for deleterious alleles using the values provided at Boyko et al. (2008). ","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"adap = MKtest.parameters(n=661,al_tot=0.4,al_low=0.2,gH=500,gam_neg=-457,al=0.184,be = 0.184/457,B=0.999)","category":"page"},{"location":"analytical/#Solving-the-model","page":"Analytical estimations","title":"Solving the model","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Here we solve alpha_(x) generally, using the expected rates. We are not considering any specific mutation process over a locus and branch time. We used the fixation and polymorphic rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be cancelled","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"x,y = MKtest.analytical_alpha(param = adap)","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Internally the function (1) sets the mutation rate regarding the BGS strength and (2) sets the probability of fixations given the genetic scenario. Then, it estimates the SFS and fixations rates for neutral and non-neutral alleles. Please check MKtest.analytical_alpha to check the process.","category":"page"},{"location":"analytical/#Plotting-the-results.","page":"Analytical estimations","title":"Plotting the results.","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"The variable x contains alpha_(x) accounting for weakly beneficial alleles. y contains the value of alpha_(x), not accounting for weakly beneficial alleles. In this example, we do not model BGS (check B parameter in MKtest.parameters above)","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"In Julia, you can easily use R using the module RCall. Please check you have installed R in your system. Nonetheless, you can plot using the Julia Plots module.","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"If you are using our Docker or Singularity image, you don't need to install anything. Otherwise, install RCall just in case you want to plot using R","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"using Pkg\nPkg.add(\"RCall\")","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"using RCall\n\nR\"\"\"\n\tlibrary(ggplot2)\n\tlibrary(data.table)\n\tdf = data.table(f=seq(1,length($x)),x=$x,y=$y)\n\td  = melt(df,id.vars='f')\n\tp = ggplot(d,aes(x=f,y=value,color=variable)) + geom_line() + geom_point() + scale_colour_manual(values=c('#30504f', '#ab2710'),labels = c(\"Neutral + deleterious alleles\", \"All alleles\")) + theme_bw()\n\tp\n\"\"\"","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"(Image: image)","category":"page"},{"location":"data/#Parsing-genomic-data","page":"Processing data","title":"Parsing genomic data","text":"","category":"section"},{"location":"data/","page":"Processing data","title":"Processing data","text":"The module includes functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019). In addition, the module have a function to parse SFS and divergence from multi-FASTA data following Murga-Moreno et al. (2019)","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"Please to parse raw data into SFS and divergence counts, first download raw files deposited in our repository:  ","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"TGP\nDGN Zambia population  \nDGN Raleigh population  ","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"mkdir(\"analysis/\")\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"analysis/tgp.txt\")\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/dgn_ral.txt\",\"analysis/dgn_ral.txt\")","category":"page"},{"location":"data/#Parsing-TGP-and-DGN-data-manually","page":"Processing data","title":"Parsing TGP and DGN data manually","text":"","category":"section"},{"location":"data/","page":"Processing data","title":"Processing data","text":"Once you have downloaded the files, you can use the function MKtest.parse_sfs to convert the data into SFS and divergence counts. Please check MKtest.parse_sfs to get more info o execute:","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"alpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\")","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"To save the data, you can use CSV and DataFrames packages","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"using CSV, DataFrames\nCSV.write(\"analysis/tpg_sfs.tsv\",DataFrame(sfs,:auto),delim='\\t',header=false)\nCSV.write(\"analysis/tpg_div.tsv\",DataFrame(permutedims(divergence),:auto),delim='\\t',header=false)","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"It is possible to directly subset genes IDs using Ensembl or Flybase id. Use a variable of type Matrix{String} or Vector{String} into the argument gene_list. The input Matrix{String} will be subset by columns creating ncol SFS and divergence Matrix.","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembl_list.txt\",\"analysis/ensembl_list.txt\")\nensembl_list = CSV.read(\"analysis/ensembl_list.txt\",header=false,DataFrame) |> Array\n\nalpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\",gene_list = ensembl_list)","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"If you are going to perform a bootstrap analysis you can input a Matrix{String} to subset the bootstraped gene ids and create the SFS and divergence files.","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/example_bootstrap\",\"analysis/example_bootstrap.txt\")\n\nbootstrap_list = String.(Array(CSV.read(\"analysis/example_bootstrap.txt\",DataFrame))[:,2:end])\n\n# In our case, eachrow is a bootstrapped set\nalpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\",gene_list = bootstrap_list)","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"If you are going to parse DGN, you need to change the value of the argument isoline to true. Following the Murga-Moreno et al. (2019) sample size for each population is:","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"Zambia population: 154\nRAL population: 160","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"alpha, sfs, divergence = MKtest.parse_sfs(sample_size = 160, data = \"analysis/dgn_ral.txt\",isolines=true)","category":"page"},{"location":"input/#Input-data","page":"Input data","title":"Input data","text":"","category":"section"},{"location":"input/","page":"Input data","title":"Input data","text":"To estimate summary statistics, you need to provide empirical SFS and divergence files. As explained in section data, you can directly parse TGP or DGN data using our module. Nonetheless, you can input any other SFS and divergence file.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"You can easily use Julia to download the files using Julia or Bash. You also can download the files manually.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"analysis/tgp.txt\")","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"To standardize the estimation, the summary statitics ABC inference functions will search SFS, divergence files into a folder containing both file with prefix sfs and div. The function MKtest.parseSfs will parse the raw data, creating two variables of type: Matrix{Float64} and Vector{Int64} required to estimate summary statistics.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"alpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\")","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"Once you have estimated (or download) the analytical rates and parsed the SFS and divergence information, you can estimate the summary statistics.","category":"page"},{"location":"multiple/#Infering-the-adapation-rate-from-multiple-datasets","page":"Multiple dataset","title":"Infering the adapation rate from multiple datasets","text":"","category":"section"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"As we explained at section Input Data it is possible to subset the TGP dataset given a matrix of Ensembl/Flybase ids. In this section we will use whole-genome protein-coding information, Viral Interacting Proteins and Non-Viral Interacting Proteins to infer the empirical adaptation.","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"The next step assume that you execute the previous sections. Please before to execute this example, be sure you already performed the rates estimates and your analysis/ folder contain the TGP data.","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"We are going to create three separate directories into the analysis/ directory we are working with to perform the estimations. You can create the folder manually, through bash, or directly in the Julia interpreter","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"using Distributed\naddprocs(7)\n@everywhere using MKtest\nusing CSV, DataFrames, JLD2\n\nadap = MKtest.parameters(n=661,dac=[2,4,5,10,20,50,200,661,925])\n\nmkpath(\"analysis/wg/\")\nmkpath(\"analysis/vips/\")\nmkpath(\"analysis/nonvips/\")","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Once you have the folder please download from our repository the files containing the VIPs and Non-VIPs ids.","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/vip_list.txt\",\"analysis/vips/vip_list.txt\")\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/nonvip_list.txt\",\"analysis/nonvips/nonvip_list.txt\")","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Now we are going to parse our three dataset to output the SFS and divergence files into each analysis folder. We we follow the example provided at Input Data section. Once you have the data parsed, you can estimate the summary statistic following Summary statistic section. Load the rates and select a DAC before to continue the analysis. And finally you can perform the ABC inference using ABCreg or another ABC software using the files alphas.txt and summaries.txt deposited in each folder. We will perform the inference using ABCreg. Please compile ABCreg before to perform the execution as described in the Installation","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Whole-Genome dataset","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"alpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\")\n\n@time summstat = MKtest.summary_statistics(param=adap,sfs=sfs,divergence=divergence,h5_file=\"analysis/rates.jld2\",analysis_folder=\"analysis/wg/\",summstat_size=10^5,bootstrap=100);\n\nMKtest.ABCreg(analysis_folder=\"analysis/wg/\",P=5,S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"VIPs dataset","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"vips = String.(CSV.read(\"analysis/vips/vip_list.txt\",header=false,DataFrame) |> Array)\n\nalpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\",gene_list=vips)\n\n@time summstat = MKtest.summary_statistics(param=adap,sfs=sfs,divergence=divergence,h5_file=\"analysis/rates.jld2\",analysis_folder=\"analysis/vips/\",summstat_size=10^5,bootstrap=100);\n\nMKtest.ABCreg(analysis_folder=\"analysis/vips/\",P=5,S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Non-VIPs dataset","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"nonvips_list = String.(CSV.read(\"analysis/nonvips/nonvip_list.txt\",DataFrame) |> Array)\n\nalpha, sfs, divergence = MKtest.parse_sfs(sample_size = 661, data = \"analysis/tgp.txt\",gene_list=nonvips_list)\n\n@time summstat = MKtest.summary_statistics(param=adap,sfs=sfs,divergence=divergence,h5_file=\"analysis/rates.jld2\",analysis_folder=\"analysis/nonvips/\",summstat_size=10^5,bootstrap=100);\n\nMKtest.ABCreg(analysis_folder=\"analysis/nonvips/\",P=5,S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");\n","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Once the posterior distributions are estimated you can perform the Maximum-A-Posterior (MAP) estimates. We performed the MAP estimates following ABCreg examples. Please be sure you have installed R and the packages(ggplot2, locfit and data.table). This packages are already installed in Docker and Singularity images. Load the R functions to estimate and plot MAP executing the following command","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"MKtest.source_plot_map_r(\"analysis/script.jl\")","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Whole-Genome dataset","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"tgpmap = MKtest.plot_map(analysis_folder=\"analysis/wg/\");\nDataFrames.describe(tgpmap[2])\n\n5×7 DataFrame\n Row │ variable  mean          min          median        max          nmissing  eltype   \n     │ Symbol    Float64       Float64      Float64       Float64      Int64     DataType \n─────┼────────────────────────────────────────────────────────────────────────────────────\n   1 │ aw           0.104377     0.0350986     0.110202      0.184566         0  Float64\n   2 │ as           0.0481464   -0.004137      0.0441584     0.114982         0  Float64\n   3 │ a            0.151626     0.110054      0.148903      0.203543         0  Float64\n   4 │ gamNeg    1302.71       612.844      1474.7        1742.59             0  Float64\n   5 │ shape        0.141999     0.130137      0.141801      0.15542          0  Float64\n\n","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"VIPs dataset","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"vipsmap = MKtest.plot_map(analysis_folder=\"analysis/vips/\");\nDataFrames.describe(vipsmap[2])\n\n5×7 DataFrame\n Row │ variable  mean        min          median      max          nmissing  eltype   \n     │ Symbol    Float64     Float64      Float64     Float64      Int64     DataType \n─────┼────────────────────────────────────────────────────────────────────────────────\n   1 │ aw          0.131834   -0.016945     0.14184      0.284644         0  Float64\n   2 │ as          0.160363    0.0780512    0.157498     0.27026          0  Float64\n   3 │ a           0.284903    0.229213     0.283095     0.369928         0  Float64\n   4 │ gamNeg    807.123     583.229      657.89      1594.79             0  Float64\n   5 │ shape       0.202337    0.17996      0.201092     0.235535         0  Float64","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"Non-VIPs dataset","category":"page"},{"location":"multiple/","page":"Multiple dataset","title":"Multiple dataset","text":"nonvipsmap = MKtest.plot_map(analysis_folder=\"analysis/nonvips/\");\nDataFrames.describe(nonvipsmap[2])\n\n5×7 DataFrame\n Row │ variable  mean          min          median        max          nmissing  eltype   \n     │ Symbol    Float64       Float64      Float64       Float64      Int64     DataType \n─────┼────────────────────────────────────────────────────────────────────────────────────\n   1 │ aw           0.0982744    0.0320596     0.098271      0.196821         0  Float64\n   2 │ as           0.0438451   -0.001272      0.0450831     0.099763         0  Float64\n   3 │ a            0.140408     0.0964904     0.141531      0.196149         0  Float64\n   4 │ gamNeg    1441.17       681.867      1547.24       1773.32             0  Float64\n   5 │ shape        0.134675     0.12122       0.135073      0.148782         0  Float64\n","category":"page"},{"location":"empirical/#Infering-the-rate-and-strength-of-adaptation","page":"Empirical estimation","title":"Infering the rate and strength of adaptation","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We develop an extension of the analytical approximation presented in Uricchio, Petrov, and Enard (2019). In the previous paper, analytical calculations were used to explore the effect of BGS on weakly beneficial alleles, but the estimation procedure employed was based on computationally intensive simulations. While inference procedures based on forward simulations allow for the inclusion of complex demographic histories, they often require high-performance computing resources and can be prohibitively slow for some models. Here we extend Uricchio, Petrov and Enard (2019) analytical approximations to develop a simple and computationally efficient ABC-based inference procedure. Our method accounts for the DFE of deleterious and beneficial alleles and incomplete recombination between selected genomic elements. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"To perform the empirical estimation of alpha_(x) we followed a generic ABC algorithm (Beaumont et al 2002). ABC proceeds by first sampling parameter values from prior distributions, the next simulating model using these parameter values, calculating informative summary statistics, and comparing the simulated summary statistics to the observed data. Considering the standard ABC scheme, we (1) considered N random combinations from prior distributions; (2) solved N independent models to generate informative summary statistics; (3) subset the parameter values producing summary statistics that best match the observed data from an approximate posterior distribution. Additionally, a linear model can be imposed to correct the non-0 distance between the simulated and observed summary statistics.","category":"page"},{"location":"empirical/#Extending-analytical-estimations","page":"Empirical estimation","title":"Extending analytical estimations","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We extended the analytical calculations solving N independents models. We automatize the analytical estimations to input prior distributions. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The models will be solved using random combinations from prior distributions. Fixation, polymorphic rates, and model information will be used to estimate informative summary statistics needed to perform ABC inference. Please see section rates to check how to input prior distributions.","category":"page"},{"location":"empirical/#Summary-statistics","page":"Empirical estimation","title":"Summary statistics","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"\\cite{uricchioexploiting2019} used the analytical theory to demonstrate the effect of weakly beneficial alleles at alpha_(x). To do that, they solved alpha_(x) through the fixation and polymorphism rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be canceled","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Here, we extended their analytical calculations to generate the summary statistics required at ABC approaches. Thereby we avoided expensive forward simulations. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Considering fixed values of T, L, mu, and fixation rates it is possible to solve analytical alpha_(x) performing the multiplication. However, this requires not only branch length estimations but also explicitly locus length selection which highly increases the order of estimations to solve. To avoid branch length estimations and locus length selection, we follow the previously described assumptions: (1) empirically observed fixations should be proportional to T, L and mu; (2) the mutational process follows a Poisson distribution . Based on that premises, we used a Poisson-sampling process to estimate the expected number of fixations. We corrected the analytical expected rates by the empirical observations as the rate of success lambda on the Poisson distribution","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED = X in Poissonleft(lambda = D_observed times (mathbbEd_++mathbbEd_-+mathbbEd_0)right)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"To estimate alpha_(x) we draw the expected values considering each fixation category. We sampled the values in two categories according to the relative rates. Following the same procedure:","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_0mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_N = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_+ + mathbbEd_-mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Our model takes into account that both sampling variance and process variance should affect the number of variable alleles that we sample at any particular allele frequency. The process variance arises from the random mutation-fixation process along the branch. To incorporate that variance we made one sample per frequency-bin given the SFS. Considering the random process at each frequency we made credible intervals for future ABC estimations. Otherwise, we would falsely find higher confidence in our parameter estimates. We draw the expected polymorphic values similarly to fixations, considering the SFS and the expected rates.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbEP = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) observed times (mathbbEp_+(x)+mathbbEp_-(x)+mathbbEp_0(x))right)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We modified the expected polymorphic rates and the observed SFS considering each frequency x as the cumulative sum above x. This quantities have the same asymptote but are less affected by changing sample size. Therefore, we scaled better the analysis to sample size since most common alleles at frequencies x have very few polymorphic sites in large samples. This way, we finally transformed alpha_(x) to be depending on the previous frequency bin value, which reflects each frequency category over the expected asymptotic shape. Because of that, alpha_(x) analysis is more robust even in low polymorphic populations.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Consequently, for each analytical combination, it is possible to sample the expected number of fixations and polymorphism to perform the alpha_(x) estimations. Like in \\cite{uricchioexploiting2019} we input alpha_(x) as summary statistic at generic ABC algorithm. We exploited summary statistics selection that are informative for estimating alpha_(x) values.","category":"page"},{"location":"empirical/#Parameters-inference","page":"Empirical estimation","title":"Parameters inference","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We used the expected proportion of weakly and strong fixations to estimate alpha_W, alpha_S and alpha. We followed the same procedure as the above section to subset the expected number of fixation taking into account weakly, strong and deleterious fixation rates categories. Therefore, we modified \\hyperref[eqn 19]{eqn 19} according to their relative fixation rates.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_W = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_WmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_SmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"In addition, for each model, we retrieve negative selection coefficients and shape parameter to perform ABC inference.","category":"page"},{"location":"empirical/#Computational-pipeline","page":"Empirical estimation","title":"Computational pipeline","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The following sections describe a pipeline to estimate the empirical adaptation rate (alpha) using whole-genome protein, Viral Interacting Proteins and Non-Viral Interacting Protein data from the TGP. This analysis is similar to the one performed at Uricchio et. al (2019). We divided the pipeline into the following step:","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"MKtest estimations\nEmpirical data parse\nSummary statistic estimation\nABC inference","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Please note that we use a relative path called analysis/ to execute the whole pipeline. This path will be relative to the where Julia or the Command-Line Interface is executed.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The software is prepared to parallelize each pipeline step using Julia Distributed computing. Distributing the process into threads has a cost in RAM. Please make some tests in your machine before executing expensive models. Nonetheless, distributing the estimation into threads decreases the pipeline execution time. It is almost mandatory to parallelize at least the rate estimations.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The following examples, as well as the analysis described at REF, were tested using a laptop with the following hardware:","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Intel i7-7700HQ (8) @ 3.800GHz \n16GB RAM DDR4 2400MHz","category":"page"},{"location":"abc/#ABC-inference-from-empirical-data","page":"ABC inference","title":"ABC inference from empirical data","text":"","category":"section"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. Remember you need to install ABCreg before continue. Please check home page to install ABCreg.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"It is possible to perform the inference through Julia. We set the tolerance value such that 2500 acceptances were recorded for the inference","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"MKtest.ABCreg(analysis_folder=\"analysis/\",S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"The function will output one file per bootstrapped replicas containing the posteriors distributions. The posterior distributions contains five columns corresponding to :","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα: Adaptation rate\nγ: Negative selection coefficient\nβ: DFE shape parameter","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"We used R to estimate the Maximum-A-Posteriori (MAP) from posterior distributions following ABCreg examples. We linked Julia and R internally. The module contains functions to perform the estimations without quit the Julia session.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"If you will perform MAP estimates and plot using our module, be sure you have installed R and the following packages: ggplot2 and data.table, locfit. ","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"MKtest.source_plot_map_r(\"analysis/script.jl\")\nposterior, tgp_map = MKtest.plot_map(analysis_folder=\"analysis/\");\nDataFrames.describe(tgp_map)","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":" Row │ variable  mean          min           median        max          nmissing  eltype   \n     │ Symbol    Float64       Float64       Float64       Float64      Int64     DataType \n─────┼─────────────────────────────────────────────────────────────────────────────────────\n   1 │ aw           0.108927     0.010857       0.108796      0.19754          0  Float64\n   2 │ as           0.0506607   -0.00750128     0.0514826     0.134143         0  Float64\n   3 │ a            0.152842     0.0962341      0.149083      0.233131         0  Float64\n   4 │ gam_neg    1184.81       512.458       1277.47       1903.12             0  Float64\n   5 │ shape        0.142934     0.128369       0.14189       0.167394         0  Float64","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"(Image: image)","category":"page"},{"location":"cli/#Command-Line-Interface","page":"Command-Line interface","title":"Command-Line Interface","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We develop a Command-Line Interface (CLI) in case you want to avoid Julia interpreter. You can easly download abcmk_cli.jl. The CLI have different functions to perform the whole pipeline as explained in Infering the rate and strength of adaptation section","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl  ","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"See --help of each command for usages  \n  rates  \n  data\n  summaries  \n  inference  ","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To reproduce the examples you can follow the steps described at Empirical estimation section","category":"page"},{"location":"cli/#Estimating-rates","page":"Command-Line interface","title":"Estimating rates","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To perform the rate estimations you can use the function rates at the CLI. The function works simirarly to the function MKtest.rates. You can check the argument at Rates sectino or using the macro @doc MKtest.rates in the Julia interpreter.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl rates --help\nFunction to solve fixation and polymorphic rates analitically. The function will create N random models from prior values. Use the arguments to defined the input range for each parameter.\n\nIf rho and/or theta are set to nothing, the function will input random values given the range 0.0005:0.0005:0.01. Otherwise you can fix the values.\n\nIf gL is set to nothing, the function will not account the role of the weakly selected alleles in the estimation.\n\nIf scheduler is set to threads the software will be run using multi-threading, not distributed computing. Please be sure you start up Julia using the same number of threads as the argument nprocs using the option julia -J nprocs\n\nThe function returns a HDF5 file containing models solved and rates. The rates will be used to compute summary statistics required at ABC.\n\nPlease check the documentation to get more info about models parameters or detailed arguments description https://jmurga.github.io/MKtest.jl/dev/cli/ to check model\n\nOptional Arguments:\n  --ne: Int64 (default: 1000)\n  --samples: Int64 (default: 661)\n  --alpha: String (default: 0.1,0.9)\n  --gam-neg: String (default: -1000,-200)\n  --gL: String (default: 5,10)\n  --gH: String (default: 400,1000)\n  --dac: String (default: 1,2,4,5,10,20,50,100,200,400,500,661,925,1000)\n  --shape: Float64 (default: 0.184)\n  --rho: String (default: nothing)\n  --theta: String (default: nothing)\n  --iterations: Int64 (default: 100000)\n  --output: String (default: /home/jmurga/rates.jld2)\n  --scheduler: String (default: local)\n  --nprocs: Int64 (default: 1)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"If you are going to perform the estimation in a HPC, please set the variable scheduler using the name of the HPC task manager. By default the value is set to local","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"time julia abcmk_cli.jl rates --samples 661 --gamNeg -2000,-200 --gL 1,10 --gH 200,2000 --rho 0.001 --theta 0.001 --solutions 100000 --output analysis/rates.jld2 --dac 1,2,4,5,10,20,50,100,200,400,500,661,925,1000 --nthreads 7 --scheduler local","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"If you are going to perform the estimation in an laptop, please set the variable scheduler to threads and start julia using the same number of threads as defined in the variable nprocs","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"nprocs=7\njulia -t${nprocs} abcmk_cli.jl \n\n## Parse data into new folder\nTo estimate summary statistics, you need to provide empirical SFS and divergence files. As explained in section [data](data.md), you can directly parse TGP or DGN data using our module. Nonetheless, you can input any other SFS and divergence file.\n\nThe function ```data``` will create a folder containing TGP or DGN raw data, parsed SFS and divergence files. Otherwise you can specify an exisiting folder.\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmk_cli.jl data –help","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmkcli.jl data –analysisfolder analysis/ –genelist analysis/dnavips.txt","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"Function to parse polymorphic and divergence data from Uricchio et. al (2019) and Murga-Moreno et al (2019). Please input a path to create a new analysis folder. You can filter the dataset using a file containing a list of Ensembl IDs. ","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"The function returns files containing raw polymorphic and divergence data, parsed SFS and parsed divegence required to estimate summary statistics.\t","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"Please check the documentation to get more info https://jmurga.github.io/MKtest.jl/dev/cli/","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"Optional Arguments:   –analysisfolder: String (default: <folder>)   –dataset: String (default: tgp)   –genelist: String (default: false)   –bins: String (default: false)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmkcli.jl data –analysisfolder analysis/","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"\nRemember you can use the argument ```gene_list``` to subset genes from TGP or DGN data using a list of Ensembl or Flybase ID. Please check [Multiple dataset](https://jmurga.github.io/MKtest.jl/dev/multiple/) to get more info.\n\n## Estimate summary statistics\n\nTo estimate summary statistics, we used the estimated analytical rates and empirical data following the description at section [Empirical estimation](empirical.md).\n\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmk_cli summaries –help","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmkcli.jl summaries –analysisfolder analysis/ –rates analysis/rates.jld2 –samples 661 –dac 2,4,5,10,20,50,200,661,925 –summstatSize 1000000","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"Estimate summary statistics from analytical rates. You must provide a path containing the parsed SFS and divergence file.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"The function returns files containing bootstrapped datasets (alphas.txt) and summary statistics (summstat.txt)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"Check the documentation to get more info https://jmurga.github.io/MKtest.jl/dev/cli","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"Optional Arguments:   –analysis_folder: String (default: <folder>)   –rates: String (default: rates.jld2)   –ne: Int64 (default: 1000)   –samples: Int64 (default: 500)   –dac: String (default: 2,4,5,10,20,50,200,500,700)   –summstatSize: Int64 (default: 100000)   –replicas: Int64 (default: 100)   –bootstrap: String (default: true)   –scheduler: String (default: local)   –nthreads: Int64 (default: 1)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"\nThe function will output observed data bootstraped (*alphas.txt*) and summary statistics (*summaries.txt*) in the analysis_folder. These file will be used at ABC inference to generate posterior distributions.\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmkcli.jl summaries –analysisfolder analysis/ –rates  analysis/rates.jld2 –samples 661 –replicas 100 –summstatSize 100000 –dac 2,4,5,10,20,50,200,661,925","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"\n## Perform ABC inference\nAt this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our [home page](index.md), we performed the ABC inference using [ABCreg](https://github.com/molpopgen/ABCreg). However, you can used other ABC software to perform the inference.\n\nWe link [ABCreg](https://github.com/molpopgen/ABCreg) with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please [cite the publication](https://doi.org/10.1186/1471-2156-10-35). Remember you need to install ABCreg before continue. Please check [home page](index.md) to install ABCreg.\n\nIt is possible to perform the inference through Julia. The function will output one file per bootstrapped replicas containing the posteriors distributions. We set the tolerance value to record 1000 values for the regression.  The posterior distributions contains five columns corresponding to:\n\n - α weak: Contribution of weak selecction to $\\alpha$\n - α strong: Contribution of strong selecction to $\\alpha$\n - α weak: Adaptation rate\n - γ: Negative selection coefficient\n - β: Negative selection coefficient\n\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia abcmkcli.jl abcInference –analysisfolder analysis/ –S 9 –tol 0.01 –ABCreg /home/jmurga/ABCreg/src/reg","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"\n## Estimate Maximum-A-Posteriori and plot using R. \n\nUsing julia expression, cannot input into *abcmk_cli.jl* (in development)\n\nWe used R to estimate the Maximum-A-Posteriori (MAP) from posterior distributions following ABCreg examples. We linked Julia and R internally. The module contains functions to perform the estimations without quit the Julia session.\n\nIf you will perform MAP estimates and plot using our module, be sure you have installed R and the following packages: ggplot2 and data.table, locfit. \n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"bash julia -e 'using MKtest, RCall, GZip, DataFrames, CSV;MKtest.sourcePlotMapR(script=\"analysis/script.jl\"); MKtest.plotMap(analysis_folder=\"analysis/\");' ``` ","category":"page"},{"location":"mk/#MK-approaches","page":"MK approaches","title":"MK approaches","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"We included other heuristic MK approaches in our module. All the functions use the formated SFS and divergence data described at data section.","category":"page"},{"location":"mk/#Standard-MKT","page":"MK approaches","title":"Standard MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The standard McDonald & Kreitman test (MKT) (McDonald and Kreitman, 1991) was developed to be applied to protein coding sequences, combining both divergence (D) and polymorphism (P) sites, and categorizing mutations as synonymous (P0, D0) and non-synonymous (Pi, Di). ","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"If all mutations are either strongly deleterious or neutral, then DiD0 is expected to roughly equal PiP0. In contrast, if positive selection is operating in the region, adaptive mutations rapidly reach fixation and contribute more to divergence than polymorphism compared to neutral mutations, and then DiD0  PiP0. Assuming that adaptive mutations contribute little to polymorphism but substantially to divergence, the proportion of non-synonymous substitutions is inferred following Smith and Eyre-Walker (2002)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_iP_0cdotfracD_0D_i)","category":"page"},{"location":"mk/#Fay,-Waycoff-and-Wu-MKT","page":"MK approaches","title":"Fay, Waycoff and Wu MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Fay et al. (2001) proposed an approach that removes all polymorphisms segregating at a frequency below a given threshold (usually 5%–15%). Although there is no consensus about what this threshold should be used, J. Charlesworth & Eyre-Walker (2008) demonstrated that  estimates are robust using a frequency threshold of 15%, below which most slightly deleterious polymorphisms are found and removed. The estimates are reasonably accurate only when the rate of adaptive evolution is high and the Distribution of Fitness Effects (DFE) of deleterious mutations is leptokurtic (J. Charlesworth & Eyre-Walker, 2008).","category":"page"},{"location":"mk/#imputed-MKT-(in-preparation)","page":"MK approaches","title":"imputed MKT (in preparation)","text":"","category":"section"},{"location":"mk/#Asymptotic-MKT","page":"MK approaches","title":"Asymptotic MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Proposed by Messer and Petrov (2013). This extension is robust to the presence of selective sweeps (genetic hitchhiking) and the segregation of slightly deleterious polymorphisms substitutions (BGS). In this approach, the authors defined alpha as a function that depends on the SFS of alleles. Therefore, alpha is estimated in different frequency intervals (x), and these values are then adjusted to an exponential function. An exponential fit is suitable as the non-synonymous allele frequency is expected to decay exponentially over the respective levels of synonymous polymorphisms (Messer & Petrov, 2013).","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_fit(x) = a+b cdot e^-cx","category":"page"},{"location":"reference/#Model-parameters","page":"Reference","title":"Model parameters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"adap is the only variable exported from MKtest module. It is a Mutable structure contaning the variables required to solve the analytical approach. Any value can be easly changed. Remember adap should be change before the execution, in other case, alpha_(x) will be solve with the default values. To change all the values at once, you can use MKtest.parameters in order to set specific models in a new variable.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parameters\nMKtest.Br\nMKtest.set_θ!\nMKtest.set_ppos!\nMKtest.binom_op!\nMKtest.Φ\nMKtest.analytical_alpha","category":"page"},{"location":"reference/#MKtest.parameters","page":"Reference","title":"MKtest.parameters","text":"Mutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. You should declare a mutable structure to the perform the analytical estimations.\n\nParameters\n\ngam_neg::Int64: Selection coefficient for deleterious alleles\ngL::Int64: Selection coefficient for weakly benefical alleles\ngH::Int64: Selection coefficient for strongly benefical alleles\nal_low::Float64: Proportion of α due to weak selection\nal_tot::Float64: α\nθ_noncoding::Float64: Mutation rate defining BGS strength\nθ_coding::Float64: Mutation rate on coding region\nal::Float64: DFE shape parameter \nbe::Float64: DFE scale parameter\nB::Float64: BGS strength\nB_bins::Array{Float64,1}: BGS values to simulate\nppos_l::Float64: Fixation probabily of weakly beneficial alleles\nppos_h::Float64: Fixation probabily of strongly beneficial alleles\nN::Int64: Population size\nn::Int64: Sample size\nLf::Int64: Flanking region length\nρ::Float64: Recombination rate\nTE::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#MKtest.Br","page":"Reference","title":"MKtest.Br","text":"Br(Lmax,theta)\n\nExpected reduction in nucleotide diversity. Explored at Charlesworth B., 1994:\n\nfracpipi_0 = e^frac4muL2rL+t\n\nArguments\n\nparam::parameters\ntheta::Float64\n\nReturns\n\nFloat64: expected reduction in diversity given a non-coding length, mutation rate and defined recombination.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.set_θ!","page":"Reference","title":"MKtest.set_θ!","text":"set_θ!(param)\n\nFind the optimum mutation given the expected reduction in nucleotide diversity (B value) in a locus.\n\nReturns\n\nadap.θ_noncoding::Float64: changes adap.θ_noncoding value.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.set_ppos!","page":"Reference","title":"MKtest.set_ppos!","text":"set_ppos!(param)\n\nFind the probabilty of positive selected alleles given the model. It solves a equation system taking into account fixations probabilities of weakly and strong beneficial alleles.\n\nReturns\n\nTuple{Float64,Float64}: weakly and strong beneficial alleles probabilites.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.binom_op!","page":"Reference","title":"MKtest.binom_op!","text":"binom_op(param)\n\nBinomial convolution to sample the allele frequencies probabilites depending on background selection values and sample size.\n\nArguments\n\nparam::parameters\nbinom::binomialDict\n\nReturns\n\nArray{Float64,2}: convoluted SFS for each B value defined in the model (param.B_bins). The estimations are saved at convolutedBn.bn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Φ","page":"Reference","title":"MKtest.Φ","text":"Φ(param,gamma,ppos)\n\nReduction in fixation probabilty due to background selection and linkage. The formulas used have been subjected to several theoretical works (Charlesworth B., 1994, Hudson et al., 1995, Nordborg et al. 1995, Barton NH., 1995).\n\nThe fixation probabilty of selected alleles are reduce by a factor phi:\n\nphi(ts) = e^frac-2mut(1+fracrLt+frac2st)\n\nMultiplying across all deleterious linkes sites, we find:\n\nPhi = prod_1^L = phi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nphi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nArguments\n\ngamma::Int64: selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.analytical_alpha","page":"Reference","title":"MKtest.analytical_alpha","text":"analyticalAlpha(param, binom)\n\nAnalytical α(x) estimation. Solve α(x) generally. We used the expected rates of divergence and polymorphism to approach the asympotic value accouting for background selection, weakly and strong positive selection. α(x) can be estimated taking into account the role of positive selected alleles or not. In this way we explore the role of linkage to deleterious alleles in the coding region.\n\nmathbbEalpha_x =  1 - left(fracmathbbED_smathbbED_NfracmathbbEP_NmathbbEP_Sright)\n\nArguments\n\nparam::parameters\n\nReturns\n\nArray{Float64,1} α(x).\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest-estimation","page":"Reference","title":"MKtest estimation","text":"","category":"section"},{"location":"reference/#Fixations","page":"Reference","title":"Fixations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.fix_neut\nMKtest.fix_neg_b\nMKtest.p_fix\nMKtest.fix_pos_sim","category":"page"},{"location":"reference/#MKtest.fix_neut","page":"Reference","title":"MKtest.fix_neut","text":"fix_neut()\n\nExpected neutral fixations rate reduce by B value.\n\nmathbbED_s = (1 - p_- - p_+) B frac12N\n\nReturns\n\nFloat64: expected rate of neutral fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fix_pos_sim","page":"Reference","title":"MKtest.fix_pos_sim","text":"fix_pos_sim(gamma,ppos)\n\nExpected positive fixations rate reduced due to the impact of background selection and linkage. The probabilty of fixation of positively selected alleles is reduced by a factor Φ across all deleterious linked sites Analytical.Φ.\n\nmathbbED_n+ =  Phi cdot mathbbED_n+\n\nArguments\n\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polymorphism","page":"Reference","title":"Polymorphism","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.sfs_neut\nMKtest.sfs_pos\nMKtest.sfs_neg\nMKtest.cumulative_sfs","category":"page"},{"location":"reference/#MKtest.sfs_neut","page":"Reference","title":"MKtest.sfs_neut","text":"sfs_neut()\n\nExpected rate of neutral allele frequency reduce by backgrou\tnd selection. The spectrum depends on the number of individual []\n\nmathbbEPs_(x) = sumx^*=xx^*=1f_B(x)\n\nInput\n\nparam::parameters: mutable structure containing the model\nSparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected rate of neutral alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_pos","page":"Reference","title":"MKtest.sfs_pos","text":"sfs_pos(s,p)\n\nExpected rate of positive selected allele frequency reduce by background selection. The spectrum depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model.\ns::Int64: selection strength.\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected positive selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_neg","page":"Reference","title":"MKtest.sfs_neg","text":"sfs_neg(param,p)\n\nExpected rate of positive selected allele frequency reduce by background selection. Spectrum drawn on a gamma DFE. It depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected negative selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.cumulative_sfs","page":"Reference","title":"MKtest.cumulative_sfs","text":"cumulative_sfs(sfs_tmp)\n\nChanging SFS considering all values above a frequency x. The original asymptotic-MK approach takes Pn(x) and Ps(x) as the number of polymorphic sites at frequency x rather than above x, but this approach scales poorly as sample size increases. We define the polymorphic spectrum as stated above since these quantities trivially have the same asymptote but are less affected by changing sample size.\n\nArguments\n\nsfs_tmp::Vector{Float64}: SFS array\nfreqs::Bool: true/false wheter the input SFS array containing a first columns with the frequencies.\n\nOutput\n\nsfs_tmp::Vector{Float64}: SFS array\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rates","page":"Reference","title":"Rates","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.rates\nMKtest.iter_rates\nMKtest.getting_rates","category":"page"},{"location":"reference/#MKtest.rates","page":"Reference","title":"MKtest.rates","text":"rates(param::parameters,iterations::Int64,divergence::Array,sfs::Array)\n\nFunction to solve randomly N scenarios. The function will create N models, defined by Analytical.parameters(), to estimate analytically fixation and polymorphic rates for each model. The rates will be used to compute summary statistics required at ABC. The function output a HDF5 file containing the solved models, the selected DAC and the analytical rates. \n\nIf ρ and/or theta are set to nothing, the function will input random values given the range 0.0005:0.0005:0.01. Otherwise you can fix the values.\n\nIf gL is set to nothing, the function will not account the role of the weakly selected alleles in the estimation.\n\nArguments\n\nparam::parameters: mutable structure containing the model\nbinom::binomialDict : structure containing the binomial convolution\ngH::Array{Int64,1} : Range of strong selection coefficients\ngL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients\ngam_neg::Array{Int64,1} : Range of deleterious selection coefficients\ntheta::Union{Float64,Nothing} : Population-scaled mutation rate on coding region\nρ::Union{Float64,Nothing} : Population-scaled recombination rate\nshape::Float64=0.184 : DFE shape parameter\niterations::Int64 : Number of solutions\noutput::String : File to output HDF5 file\n\nReturns\n\nArray: summary statistics\nOutput: HDF5 file containing models solved and rates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.iter_rates","page":"Reference","title":"MKtest.iter_rates","text":"iter_rates(param::parameters,afac::Float64,bfac::Float64,al_tot::Float64,al_low::Float64,divergence::Array,sfs::Array)\n\nEstimating rates given a model for all B range.\n\nArguments\n\nparam::parameters\nbinom::Dict\nal_tot::Float64\nal_low::Float64\ngH::Int64\ngL::Int64\ngam_neg::Int64\nafac::Float64\nρ::Float64\nθ::Float64\n\nOutput\n\nArray{Float64,2}\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.getting_rates","page":"Reference","title":"MKtest.getting_rates","text":"getting_rates(gammaL,gammaH,ppos_l,ppos_h,observedData,nopos)\n\nEstimating analytical rates of fixation and polymorphism to approach α value accouting for background selection, weakly and strong positive selection. Output values will be used to sample from a Poisson distribution the total counts of polymorphism and divergence using observed data. \n\nArguments\n\nparam::parameters\nbinom::SparseMatrixCSC{Float64,Int64}\n\nReturns\n\nArray{Float64,2} containing solved model, fixation and polymorphic rates\n\n\n\n\n\n","category":"function"},{"location":"reference/#Summary-statistics","page":"Reference","title":"Summary statistics","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.poisson_fixation\nMKtest.poisson_polymorphism\nMKtest.sampled_from_rates\nMKtest.summary_statistics","category":"page"},{"location":"reference/#MKtest.poisson_fixation","page":"Reference","title":"MKtest.poisson_fixation","text":"poisson_fixation(observed_values,λds, λdn)\n\nDivergence sampling from Poisson distribution. The expected neutral and selected fixations are subset through their relative expected rates (fix_neut, fix_neg_b, fix_pos_sim). Empirical values are used are used to simulate the locus L along a branch of time T from which the expected Ds and Dn raw count estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily given the success rate lambda in the distribution.\n\nmathbbED_N = X in Poissonleft(lambda = D times leftfracmathbbED_+ + mathbbED_-mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nmathbbED_S = X in Poissonleft(lambda = D times leftfracmathbbED_0mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nArguments\n\nobserved_values::Array: Array containing the total observed divergence.\nλds::Float64: expected neutral fixations rate.\nλdn::Float64: expected selected fixations rate.\n\nReturns\n\nArray{Int64,1} containing the expected count of neutral and selected fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.poisson_polymorphism","page":"Reference","title":"MKtest.poisson_polymorphism","text":"poisson_polymorphism(observed_values,λps,λpn)\n\nPolymorphism sampling from Poisson distributions. The total expected neutral and selected polimorphism are subset through the relative expected rates at the frequency spectrum (fix_neut, sfs_neut,). Empirical sfs are used to simulate the locus L along a branch of time T from which the expected Ps and Pn raw count are estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily from the whole sfs given each frequency success rate lambda in the distribution.\n\nThe success rate managing the Poisson distribution by the observed count each frequency.  We considered both sampling variance and process variance is affecting the number of variable alleles we sample from SFS. This variance arises from the random mutation-fixation process along the branch. To incorporate this variance we do one sample per frequency-bin and use the total sampled variation and the SFS for the summary statistics.\n\nmathbbEP_N = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_+(x) + mathbbEP_-(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nmathbbEP_S = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_0(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nArguments\n\nobserved_values::Array{Int64,1}: Array containing the total observed divergence.\nλps::Array{Float64,1}: expected neutral site frequency spectrum rate.\nλpn::Array{Float64,1}: expected selected site frequency spectrum rate.\n\nReturns\n\nArray{Int64,2} containing the expected total count of neutral and selected polymorphism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sampled_from_rates","page":"Reference","title":"MKtest.sampled_from_rates","text":"sampled_alpha(observed_values,λds, λdn)\n\nOuput the expected values from the Poisson sampling process. Please check poisson_fixation and poisson_polymorphism to understand the samplingn process. α(x) is estimated through the expected values of Dn, Ds, Pn and Ps.\n\nArguments\n\nparam::parameters: Array containing the total observed divergence.\nd::Array: observed divergence.\nafs::Array: observed polymorphism.\nλdiv::Array{Float64,2}: expected fixations rate.\nλdiv::Array{Float64,2}: expected site frequency spectrum rates.\n\nReturns\n\nαsummaries,expdn,expds,exppn,exp_ps,ssAlpha\n\nArray{Int64,2} containing α(x) values.\nArray{Int64,1} expected non-synonymous divergence.\nArray{Int64,1} expected synonymous divergence.\nArray{Int64,1} expected non-synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,2} containing α(x) binned values.\n\nsampled_from_rates(gammaL,gammaH,ppos_l,ppos_h,observedData,nopos)\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_statistics","page":"Reference","title":"MKtest.summary_statistics","text":"summary_statistics(param::parameters,rates::JLD2.JLDFile,analysis_folder::String,summstat_size::Int64,replicas::Int64,bootstrap::Bool)\n\nEstimate summary statistics using observed data and analytical rates. analysis_folder will check for the SFS and divergence file and will be used to output summary statistics\n\nArguments\n\nparam::parameters : Mutable structure containing the models\nh5_file::String : HDF5 containing solved models, fixation and polymorphic rates\nsfs::Vector{Matrix{Float64}}: SFS matrix.\ndivergence::Vector{Matrix{Float64}} : divergence matrix.\nsummstat_size::Int64 : Number of summary statistics\nreplicas::Int64 : Number of bootstrap replicas\nbootstrap::Bool : Boolean to perform or not bootstrapping\n\nOutput\n\nSummary statistics to ABC inference\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inference-tools","page":"Reference","title":"Inference tools","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parse_sfs\nMKtest.ABCreg\nMKtest.source_plot_map_r","category":"page"},{"location":"reference/#MKtest.parse_sfs","page":"Reference","title":"MKtest.parse_sfs","text":"parse_sfs(;sample_size::Int64,data::String)\n\nFunction to parse polymorphism and divergence by subset of genes. The input data is based on supplementary material described at Uricchio et al. 2019. Please be sure the file is tabulated.\n\nGeneId Pn DAF seppareted by commas Ps DAF separated by commas Dn Ds\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\n\nArguments\n\nsample_size::Int64: data sample size.\ndata: File containing polymorphic and divergence data\ngene_list: File containing gene IDs to subset. You can perform multiple subset input a file where eachrow contain the gene IDs to subset.\nsfs_columns::Array{Int64,1}: non-synonymous and synonymous daf columns. Please introduce first the non-synonymous number.\ndiv_columns::Array{Int64,1}: non-synonymous and synonymous divergence columns. Please introduce first the non-synonymous number.\nbins::Array{Int64,1}: bin to collapse the SFS from sample_size to new bin size\n\nReturns\n\nArray{Float64,1}: α values\nArray{Float64,2}: Site Frequency Spectrum\nArray{Float64,1}: Synonymous and non-synonymous divergence counts\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.ABCreg","page":"Reference","title":"MKtest.ABCreg","text":"ABCreg(analysis_folder, replicas, S, tol, abcreg)\n\nPerforming ABC inference using ABCreg. Please, be sure your analysis_folder contain the files alphas.txt and summaries.txt produced by Analytical.summaryStatsFromRates()\n\nArguments\n\nanalysis_folder::String : Folder containing the observed data and summary estatistics. It will be used to output the posterior distributions\nP::Int64 : Number of parameters to perform the inference.\nS::Int64 : Number of summary stastitics to perform the inference.\ntol::Float64 : Tolerance value. It define the number of accepted values at ABC inference\nabcreg::String : Path to ABCreg binary\n\nOutput\n\nFiles containing posterior distributions from ABCreg\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.source_plot_map_r","page":"Reference","title":"MKtest.source_plot_map_r","text":"Function to download and source plotMap function. We do not include at part of the module to avoid external dependecies. Once the function is execute properly you will have a function called *plotMap which used R to \n\testimate and plot the Maximum A Posterior following ABCreg example. It uses locfit and ggplot2 libraries.\n\n#Arguments\n\nscript_path::String: Path and name to save MAP scritp.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest","page":"Reference","title":"MKtest","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.aMK\nMKtest.imputedMK\nMKtest.fwwMK\nMKtest.standardMK","category":"page"},{"location":"reference/#MKtest.aMK","page":"Reference","title":"MKtest.aMK","text":"aMK(x,columns)\n\nFunction to estimate the asymptotic value of α(x).\n\nArguments\n\nalpha_values::Array{Float64,1}: α(x) array.\n\nReturns\n\nArray{Float64,2}: Array of array containing asymptotic values, lower confidence interval, higher confidence interval\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.imputedMK","page":"Reference","title":"MKtest.imputedMK","text":"imputedMK(sfs,divergence,m,cutoff)\n\nFunction to estimate the imputedMK\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\nm::Union{Nothing,Array}: non-synonymous and synonymous sites\ncutoff{Float64}: frequency cutoff to perform imputedMK\n\nReturns\n\n`Dict: Dictionary containing results\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fwwMK","page":"Reference","title":"MKtest.fwwMK","text":"fwwMK(sfs,divergence,m,cutoff)\n\nFunction to estimate the Fay, Wycoff and Wu's MK extension.\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\nm::Union{Nothing,Array}: non-synonymous and synonymous sites\ncutoff{Float64}: frequency cutoff to perform fwwMK\n\nReturns\n\n`Dict: Dictionary containing results\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.standardMK","page":"Reference","title":"MKtest.standardMK","text":"standardMK(x,columns)\n\nFunction to estimate the original α value\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\nm::Union{Nothing,Array}: non-synonymous and synonymous sites# Returns\n\nOutput\n\n`Dict: Dictionary containing results\n\n\n\n\n\n","category":"function"},{"location":"summstat/#Summary-statistics","page":"Summary statistics","title":"Summary statistics","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"To estimate summary statistics, we used the estimated analytical rates and empirical data following the description at section Empirical estimation","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Before starting the summary statistics, consider parallelizing the process using Julia Distributed computing. If you are following the tutorial step by step, do not input the following commands.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using MKtest","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Before to compute the summary statistic, declare a model specifying the samples size and a DAC.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"adap = MKtest.parameters(n=661,dac=[2,4,5,10,20,50,200,661,925])","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Note you can only input DAC already estimated, nonetheles you can perform any subset from the estimated DAC. To check the estimated DAC you can follow the hierarchy of the h5 variable.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using JLD2\n# Check hierarchy\nh5   = jldopen(\"analysis/rates.jld2\")\nh5\n\nJLDFile /home/jmurga/analysis/rates.jld2 (read-only)\n └─📂 1000\n    └─📂 661\n       ├─🔢 models\n       ├─🔢 neut\n       ├─🔢 sel\n       ├─🔢 dsdn\n       └─🔢 dac","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"# Checking estimated dac, string pattern inside the HDF5 variable\nh5[\"1000/661/dac\"]\n\n14-element Vector{Int64}:\n    1\n    2\n    4\n    5\n   10\n   20\n   50\n  100\n  200\n  400\n  500\n  661\n  925\n 1000","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function MKtest.summary_statistics use the SFS and divergence Matrix output from MKtest.parse_sfs. We include the argument bootstrap to perform bootstrap analysis following polyDFE manual. In the following example we boostrap the SFS and divegence file 100 times subseting 10^5 summary statistic for each dataset:","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"@time summstat = MKtest.summary_statistics(param=adap,h5_file=\"analysis/rates.jld2\",sfs=sfs,divergence=divergence,analysis_folder=\"analysis/\",summstat_size=10^5,bootstrap=100);","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Nonetheless, you can read your SFS and divergence files using the packages CSV and DataFrames to create the input Matrix. In such case, please be sure that sfs and divergence arguments are of type Vector using square braces ([]) comprehesion","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using CSV, DataFrames\nsfs = CSV.read(\"/path/to/sfs_file.txt\", header=false, DataFrame) |> Matrix\ndivergence = CSV.read(\"/path/to/divergence_file.txt\", header=false, DataFrame) |> Matrix\n\n# Note we modified both variables into a Vector using square braces ([]) comprehesion\n@time summstat = MKtest.summary_statistics(param=adap,h5_file=\"analysis/rates.jld2\",sfs=[sfs],divergence=[divergence],analysis_folder=\"analysis/\",summstat_size=10^5,replicas=100,bootstrap=true);\n","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function will create summary statistic files and the observed data files (summaries_N.txt and alpha_N.txt respectively). Both files will be used to perform the ABC inference. Each file will be used to infer alpha using the bootstrapped SFS.","category":"page"},{"location":"#ABC-MK","page":"Home","title":"ABC-MK","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ABC-MK is an analytical approximation to alpha_(x). We have explored the impact of linkage and background selection at positive selected alleles sites. The package solves analytical approximations for different genetic scenarios to estimate the strength and rate of adaptation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Our approach directly estimates alpha_(x) and several statistics (B, alpha_W, alpha_S) associated with random DFE. In conjunction, the associated values to these DFE can be used as summary statistics at ABC methods. Therefore, our method can estimate the rate and strength of adaption in models and non-models organisms.","category":"page"},{"location":"#Docker-installation","page":"Home","title":"Docker installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We highly recommend using the Docker image to execute the software. The Docker image is based on Debian and includes all the software needed to run the pipeline. You can access to Debian system or Jupyter pulling the image from Docker Hub. Remember to link the folder /analysis with any folder at your ${HOME} directory to save the results:","category":"page"},{"location":"","page":"Home","title":"Home","text":"MYPATH=\"/home/jmurga/analysis/\"\n# Pull the image\ndocker pull jmurga/mktest\n# Run temporal docker container linking some local volume to export data. Consider to create a container.\ndocker run -it -v --rm ${MYPATH}:/analysis/folder jmurga/mktest\n# Run jupyter notebook from docker image. Change the port if 8888 is already used\ndocker run -it --rm -v ${MYPATH}:/analysis/folder -p 8888:8888 jmurga/mktest /bin/bash -c \"jupyter-lab --ip='*' --port=8888 --no-browser --allow-root\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use our command-line interface, just run","category":"page"},{"location":"","page":"Home","title":"Home","text":"docker run -it -v ${MYPATH}:/analysis/ jmurga/mktest julia /analysis/abcmk_cli.jl","category":"page"},{"location":"#Singularity-installation","page":"Home","title":"Singularity installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have created a Singularity container to use the software in HPC systems. We have tested the software at HPC working with Slurm and HTCondor scheduler","category":"page"},{"location":"","page":"Home","title":"Home","text":"singularity pull --arch amd64 library://jmurga/default/mktest:latest","category":"page"},{"location":"","page":"Home","title":"Home","text":"We found a bug regarding Singularity, ClusterManagers.jl and Slurm in our HPC tests. Please, consider to install the packages manually if your HPC works with Slurm. We provided a Julia script to easily install all the required packages. Just run it before to execute our Command-Line Interface. We provide Slurm and HTCondor examples showing the  estimation.","category":"page"},{"location":"#Scratch-installation","page":"Home","title":"Scratch installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install our module from scratch, we highly recommend using LTS official Julia binaries. Once you have installed Julia in your system, consider to install some important dependencies to automatize your ABC-MK pipelines. We have prepared a file to install them. Please download this file and execute the following command","category":"page"},{"location":"","page":"Home","title":"Home","text":"curl -o julia_dependencies.jl https://raw.githubusercontent.com/jmurga/MKtest.jl/master/scripts/julia_dependencies.jl\njulia julia_dependencies.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can easly install our Julia package executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(PackageSpec(path=\"https://github.com/jmurga/MKtest.jl\"))'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or from Pkg REPL (by pressing ] at Julia interpreter):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/jmurga/MKtest.jl","category":"page"},{"location":"#ABCreg","page":"Home","title":"ABCreg","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have linked ABCreg with Julia to perform ABC inference. Nonetheless others ABC softwares could be used (abc (R package), ABCToolBox, etc). If you are going to use ABCreg to directly make inference from our software please cite the publication and compile it in your system. Anyway, once you get the summary statistic files you can use any other ABC software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ABCreg needs GSL and libz to work. Please install both libraries before compile the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Linux debian-based installation\nsudo apt install libgsl-dev libz-dev build-essential git\n# MacOS installation\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew install GSL zlib git","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/molpopgen/ABCreg.git ABCreg\ncd ABCreg/src && make","category":"page"},{"location":"#R","page":"Home","title":"R","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have used R to estimate the Maximum-A-Posteriori (MAP) from posterior distributions following ABCreg examples. We linked Julia and R internally. The module contains functions to perform the estimations without quit the Julia session.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Linux debian-based installation\nsudo apt install r-base\n# MacOS installation\nbrew install r","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are going to perform MAP estimates and plot using our module, be sure you have installed R and the following packages: ggplot2 and data.table, locfit. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"R -e \"install.packages(c('ggplot2','data.table','locfit'))\"","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uricchio, L.H., Petrov, D.A. & Enard, D. Exploiting selection at linked sites to infer the rate and strength of adaptation. Nat Ecol Evol 3, 977–984 (2019). https://doi.org/10.1038/s41559-019-0890-6\nPhilipp W. Messer, Dmitri A. Petrov. Frequent adaptation and the McDonald–Kreitman test. Proceedings of the National Academy of Sciences May 2013, 110 (21) 8615-8620. https://doi.org/10.1073/pnas.1220835110\nNordborg, M., Charlesworth, B., & Charlesworth, D. (1996). The effect of recombination on background selection. Genetical Research, 67(2), 159-174. https://doi.org/10.1017/S0016672300033619\nR R Hudson and N L Kaplan. Deleterious background selection with recombination. Genetics December 1, 1995 vol. 141 no. 4 1605-1617.\nLinkage and the limits to natural selection. N H Barton. Genetics June 1, 1995 vol. 140 no. 2 821-841\nThornton, K.R. Automating approximate Bayesian computation by local linear regression. BMC Genet 10, 35 (2009). https://doi.org/10.1186/1471-2156-10-35","category":"page"}]
}
