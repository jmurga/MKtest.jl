var documenterSearchIndex = {"docs":
[{"location":"rates/#Estimating-expected-fixation-rates-and-frequency-spectra-considering-generalized-model-of-selection-and-linkage","page":"Rates","title":"Estimating expected fixation rates and frequency spectra considering generalized model of selection and linkage","text":"","category":"section"},{"location":"rates/","page":"Rates","title":"Rates","text":"The first step is to solve N genetic models to obtain the analytical estimations. The process is automatize to create random combination model parameters given priors distributions. The expected fixation rates and frequency spectra, polymorphic rates, and model information will be used to estimate informative summary statistics needed to perform ABC inference. The following section show how to define a genetic a model, input prior distributions and solve the models.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Before executing the rates estimation, start-up Julia using -t option to add the desired number of threads to parallelize the process","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"julia -t8","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"using MKtest\nmkpath(\"analysis/\")","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"You must to declare a variable containing some basic information about your model using the function MKtest.paramterers. Note that MKtest.parameters contains information about mutation rate, recombination rate, DFE, BGS and probabilities of fixations. To check all the arguments you can access to the function documentation using @doc MKtest.parameter","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@doc MKtest.parameters\n  Mutable structure containing the variables required to solve the analytical\n  approach. All the functions are solve using the internal values of the structure.\n  You should declare a mutable structure to the perform the analytical estimations.\n\n  Parameters\n  ≡≡≡≡≡≡≡≡≡≡≡≡\n\n    •  gam_flanking::Int64: Selection coefficient for deleterious alleles\n\n    •  gL::Int64: Selection coefficient for weakly benefical alleles\n\n    •  gH::Int64: Selection coefficient for strongly benefical alleles\n\n    •  al_low::Float64: Proportion of α due to weak selection\n\n    •  al_tot::Float64: α\n\n    •  θ_flanking::Float64: Mutation rate defining BGS strength\n\n    •  θ_coding::Float64: Mutation rate on coding region\n\n    •  al::Float64: DFE shape parameter\n\n    •  be::Float64: DFE scale parameter\n\n    •  B::Float64: BGS strength\n\n    •  B_bins::Array{Float64,1}: BGS values to simulate\n\n    •  ppos_l::Float64: Fixation probabily of weakly beneficial alleles\n\n    •  ppos_h::Float64: Fixation probabily of strongly beneficial alleles\n\n    •  N::Int64: Population size\n\n    •  n::Int64: Sample size\n\n    •  Lf::Int64: Flanking region length\n\n    •  ρ::Float64: Recombination rate\n\n    •  TE::Float64\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"We will estimate the empirical adaptation rate using TGP data using the estimated DFE parameters at Boyko et al (2008). Hence, we used a sample size of 661 to perform the analysis and the infered deleterious DFE. Note that shape DFE parameter is flexible and modified by a factor of 4 and scale DFE parameter is modified from a prior distribution when executing MKtest.rates function. In addition we will input the selected Derived Alleles Counts (DAC) to later compute summary statistics and perform ABC inference. It is possible to subset any of the selected DAC values when computing summary statistics. If you want to exclude any variant bellow or above a frequency threshold you can use the argument cutoff.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"adap = MKtest.parameters(N=10000,n=661,dac=[1,2,4,5,10,20,50,100,200,400,500,661,925,1000],gam_dfe=-457,shape=0.184,cutoff=[0.0,1.0])","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Now the variable adap contains sample size, DAC and deleterious DFE information. The function MKtest.rates will perform the analytical estimation of N independent models regarding DFE, BGS, mutation rate, and recombination rate. Please note you can edit such values when using MKtest.parameters.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Now you can used the function MKtest.rates to input the prior distributions. The function will randomize the input values to solve N independent estimation regarding our model.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"  rates(param,gH,gL,gam_flanking,gam_dfe,alpha,iterations,output)\n\n  Function to solve randomly N scenarios. The function will create N models,\n  defined by MKtest.parameters(), to solve analytically fixation rates and the\n  expected SFS for each model. The rates will be used to compute summary statistics\n  required at ABC inference. The function output a HDF5 file containing the solved\n  models, the selected DAC and the analytical solutions.\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •  param::parameters: mutable structure containing the model.\n\n    •  gH::Array{Int64,1}: Range of strong selection coefficients.\n\n    •  gL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients.\n\n    •  gam_flanking::Array{Int64,1}: Range of deleterious selection coefficients at the flanking region.\n\n    •  gam_dfe::Array{Int64,1}: Range of deleterious selection coefficients at the coding region.\n\n    •  alpha::Vector{Float64}: Range of α value to solve\n\n    •  iterations::Int64: Number of solutions.\n\n    •  output::String: File to output HDF5 file.\n\n  Returns\n  ≡≡≡≡≡≡≡≡≡\n\n    •  DataFrame: models solved.\n\n    •  Output: HDF5 file containing models solved and rates.\n\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@time df = MKtest.rates(adap,gH=[200,2000],gL=[1,10],gam_dfe=[-2000,-200],gam_flanking=[-1000,-500],iterations = 10,output=\"analysis/rates.jld2\");","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The function will create a HDF5 file containing the solved models, the expected fixation rates and frequency spectra, and the selected DAC. This information will be used later to estimate summary statistics.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Note that MKtest.rates is the most resource and time-consuming function. In our case, the function will estimate 10^5 independent models. Each model solves the estimation for all possible BGS values. We used BGS values from 0.1 to 0.999 in 5% increments (defined at adap.B_range). In total, the example will produce 3.7 million estimates. We have used a hierarchical data structure (HDF5) to facilitate model parameters and rates storage.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The following example took about 1.5 hours to execute on the hardware described at section Infering the rate and strength of adaptation","category":"page"},{"location":"analytical/#MKtest-estimation","page":"MKtest estimation","title":"MKtest estimation","text":"","category":"section"},{"location":"analytical/#Solving-\\alpha_{(x)}","page":"MKtest estimation","title":"Solving alpha_(x)","text":"","category":"section"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"Our method is based on the analytical solution of alpha_(x) given a genetic model. The approach could be extended to any DFE and background selection values to get summary statistics used at ABC methods. This example shows how the asymptotic alpha is affected by linkage and background selection.","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"Before starting, you need to set up a variable of type MKtest.parameters. It is a Mutable structure containing the parameters required to solve the analytical approach. Any value at MKtest.parameters can be easily changed. Remember, you need to define it before the execution. Otherwise, alpha_(x) will be solved with default values. To change any values, check the variables at the struct MKtest.parameters to set specific models.","category":"page"},{"location":"analytical/#Load-the-modules","page":"MKtest estimation","title":"Load the modules","text":"","category":"section"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"using MKtest","category":"page"},{"location":"analytical/#Setting-model-parameters-and-convolute-the-binomial-distribution.","page":"MKtest estimation","title":"Setting model parameters and convolute the binomial distribution.","text":"","category":"section"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"We set a global adaptation rate of 0.4 with a contribution of 0.2 regarding weak adaptation. The process is modeled using a selection coefficient of 500, 10 for strongly and weakly beneficial alleles. We modeled the DFE for deleterious alleles using the values provided at Boyko et al. (2008).","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"adap = MKtest.parameters(n=661,al_tot=0.4,al_low=0.2,gH=500,gam_dfe=-457,gam_flanking=-1000,shape=0.184,B=0.999)","category":"page"},{"location":"analytical/#Solving-the-model","page":"MKtest estimation","title":"Solving the model","text":"","category":"section"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"Here we solve alpha_(x) generally, using the expected rates. We are not considering any specific mutation process over a locus and branch time. We used the fixation and polymorphic rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be cancelled","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"x,y = MKtest.analytical_alpha(adap)","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"Internally the function (1) sets the mutation rate regarding the BGS strength and (2) sets the probability of fixations given the genetic model. Then, it estimates the SFS and fixations rates for neutral and non-neutral alleles. Please check MKtest.analytical_alpha to check the process.","category":"page"},{"location":"analytical/#Plotting-the-results.","page":"MKtest estimation","title":"Plotting the results.","text":"","category":"section"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"The variable x contains alpha_(x) accounting for weakly beneficial alleles. y contains the value of alpha_(x), not accounting for weakly beneficial alleles. In this example, we do not model BGS (check B parameter in MKtest.parameters above)","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"In Julia, you can easily use R using the module RCall. Please check you have installed R in your system. Nonetheless, you can plot using the Julia Plots module.","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"If you are using our Docker or Singularity image, you don't need to install anything. Otherwise, install RCall just in case you want to plot using R","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"using Pkg\nPkg.add(\"RCall\")","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"using RCall\n\nR\"\"\"\n\tlibrary(ggplot2)\n\tlibrary(data.table)\n\tdf = data.table(f=seq(1,length($x)),x=$x,y=$y)\n\td  = melt(df,id.vars='f')\n\tp = ggplot(d,aes(x=f,y=value,color=variable)) + geom_line() + geom_point() + scale_colour_manual(values=c('#30504f', '#ab2710'),labels = c(\"Neutral + deleterious alleles\", \"All alleles\")) + theme_bw()\n\tp\n\"\"\"","category":"page"},{"location":"analytical/","page":"MKtest estimation","title":"MKtest estimation","text":"(Image: image)","category":"page"},{"location":"data/#Parsing-genomic-data","page":"Parsing genomic data","title":"Parsing genomic data","text":"","category":"section"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"The module includes functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019).","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"Please to parse raw data into SFS and divergence counts, first download raw files deposited in our repository:  ","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"TGP\nDGN Zambia population  \nDGN Raleigh population  ","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"mkdir(\"analysis/\")\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"analysis/tgp.txt\")","category":"page"},{"location":"data/#Parsing-TGP-and-DGN-data-manually","page":"Parsing genomic data","title":"Parsing TGP and DGN data manually","text":"","category":"section"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"Once you have downloaded the files, you can use the function MKtest.parse_sfs to convert the data into SFS and divergence counts. Please check MKtest.parse_sfs to get more info or execute:","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"It is possible to directly subset genes IDs using the same ids deposited at you data. You can use a (column list file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembllist.txt] or (CSV-like file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/testnonVIPs.txt] to subset the file list. If you use CSV-like each row will be parsed independtly.","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembl_list.txt\",\"analysis/ensembl_list.txt\")\n\nalpha, sfs, divergence = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/ensembl_list.txt\")","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/example_bootstrap.txt\",\"analysis/example_bootstrap.txt\")\n\n# In our case, eachrow is a bootstrapped set\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/example_bootstrap.txt\")","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"If you are going to parse DGN, you need to change the value of the argument isoline to true. Following the Murga-Moreno et al. (2019) sample size for each population is:","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"Zambia population: 154\nRAL population: 160","category":"page"},{"location":"data/","page":"Parsing genomic data","title":"Parsing genomic data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/dgn_ral.txt\",\"analysis/dgn_ral.txt\")\nadap = MKtest.parameters(n=160,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/dgn_ral.txt\",isolines=true)","category":"page"},{"location":"input/#Parsing-genomic-data","page":"Input data","title":"Parsing genomic data","text":"","category":"section"},{"location":"input/","page":"Input data","title":"Input data","text":"To estimate summary statistics, you need to provide empirical SFS and divergence files. The module includes functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019).","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"Please to parse raw data into SFS and divergence counts, first download raw files deposited in our repository:  ","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"TGP\nDGN Zambia population  \nDGN Raleigh population  ","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"mkdir(\"analysis/\")\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"analysis/tgp.txt\")","category":"page"},{"location":"input/#Parsing-TGP-and-DGN-data-manually","page":"Input data","title":"Parsing TGP and DGN data manually","text":"","category":"section"},{"location":"input/","page":"Input data","title":"Input data","text":"Once you have downloaded the files, you can use the function MKtest.parse_sfs to convert the data into SFS and divergence counts. Please check MKtest.parse_sfs to get more info or execute:","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"It is possible to directly subset genes IDs using the same ids deposited at you data. You can use a (column list file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembllist.txt] or (CSV-like file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/testnonVIPs.txt] to subset the file list. If you use CSV-like each row will be parsed independtly.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembl_list.txt\",\"analysis/ensembl_list.txt\")\n\nalpha, sfs, divergence = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/ensembl_list.txt\")","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/example_bootstrap.txt\",\"analysis/example_bootstrap.txt\")\n\n# In our case, eachrow is a bootstrapped set\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/example_bootstrap.txt\")","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"If you are going to parse DGN, you need to change the value of the argument isoline to true. Following the Murga-Moreno et al. (2019) sample size for each population is:","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"Zambia population: 154\nRAL population: 160","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/dgn_ral.txt\",\"analysis/dgn_ral.txt\")\nadap = MKtest.parameters(n=160,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/dgn_ral.txt\",isolines=true)","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"Nonetheless, you can input any other SFS and divergence file.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"We developed an extension of the analytical approximation presented Uricchio et al. (2019). In such a paper, the authors used the analytical approximation to alpha_x to explore the effect of BGS on weakly beneficial alleles, but the empirical estimation of alpha procedure employed was based on computationally intensive forward-in-time simulations. Unfortunately, forward-in-time simulations often require high-performance computing resources and can be prohibitively slow for some models. Here we extend Uricchio et al. (2019)analytical approximations to develop a simple and computationally efficient ABC-based inference procedure modelling the DFE of deleterious and beneficial alleles and incomplete recombination between selected genomic elements. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"We followed a generic ABC scheme (Beaumont et al. (2002)) to perform the empirical estimation of alpha. ABC scheme proceeds by first sampling parameter values from prior distributions, simulating the model using these parameter values, calculating informative summary statistics, and comparing the simulated summary statistics to the observed data. Following the standard ABC scheme, we 1) considered N random combinations from prior distributions; 2) solved N independent models to generate informative summary statistics; 3) subset the parameter values producing summary statistics that best match the observed data from an approximate posterior distribution. Additionally, a linear model can be imposed to correct the non-0 distance between the simulated and observed summary statistics.","category":"page"},{"location":"empirical/#Extending-analytical-estimations","page":"Infering the rate and strength of adaptation","title":"Extending analytical estimations","text":"","category":"section"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Uricchio et al. (2019) used the analytical theory to demonstrate the effect of weakly beneficial alleles at alpha_(x). To do that, they solved alpha_(x) through the fixation and polymorphism rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be canceled","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Here, we extended their analytical calculations to generate the summary statistics required at ABC approaches. Thereby we avoided expensive forward simulations. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Considering fixed values of T, L, mu, and fixation rates it is possible to solve analytical alpha_(x) performing the multiplication. However, this requires not only branch length estimations but also explicitly locus length selection which highly increases the order of estimations to solve. To avoid performing branch length estimations in our computation, we assumed that the empirically observed number of fixations should be proportional to the length of the evolutionary branch of interest, T, the locus length L and mutation ration mu. We take the observed total number of fixations (including both nonsynonymous and synonymous sites) as a proxy for the expected number, and then sample weakly deleterious, neutral, and beneficial substitutions proportional to their relative rates for a fixed set of model parameters. The expected number of substitutions for positively selected substitutions is then","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED = X in Poissonleft(lambda = D_observed times (mathbbEd_++mathbbEd_-+mathbbEd_0)right)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"To estimate alpha_(x) we draw the expected values considering each fixation category. We sampled the values in two categories according to the relative rates. Following the same procedure:","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_0mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_N = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_+ + mathbbEd_-mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"It should be noted that both sampling variance and process variance affect the number of variable alleles at any particular allele frequency in a sequencing sample. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"To incorporate that variance we made one sample per frequency-bin given the SFS, we sampled a Poisson distributed number of polymorphic alleles at frequency x relative to their rate given the expected frequency spectra. The expected frequency spectra were downsampled using a binomial (with probability of success given by the frequency beginpmatrix x  2n endpmatrix in a sample of 2n chromosomes) to account for the sampling variance. Considering the random process at each frequency we made credible intervals for future ABC estimations. Otherwise, we would falsely find higher confidence in our parameter estimates. We draw the expected polymorphic values similarly to fixations, considering the SFS and the expected rates.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbEP = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) observed times (mathbbEp_+(x)+mathbbEp_-(x)+mathbbEp_0(x))right)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"It should be noted that we modified the expected SFS and the observed SFS considering each frequency x as the cumulative sum above x. This quantities have the same asymptote but are less affected by changing sample size. Therefore, we scaled better the analysis to sample size since most common alleles at frequencies x have very few polymorphic sites in large samples. This way, we finally transformed alpha_(x) to be depending on the previous frequency bin value, which reflects each frequency category over the expected asymptotic shape. Because of that, alpha_(x) analysis is more robust even in low polymorphic populations.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"We followed the same procedure described above to subset the expected number of fixation taking into account weakly, strong and deleterious fixation rates categories. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_W = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_WmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_SmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"In addition, for each model, we retrieve deleterious DFE parameters to perform ABC inference.","category":"page"},{"location":"empirical/#Computational-pipeline","page":"Infering the rate and strength of adaptation","title":"Computational pipeline","text":"","category":"section"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"The following sections describe a pipeline to estimate the empirical adaptation rate (alpha) using whole-genome protein, Viral Interacting Proteins and Non-Viral Interacting Protein data from the TGP. This analysis is similar to the one performed at Uricchio et al. (2019). We divided the pipeline into the following step:","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Expected fixations rates and frequency spectra estimations\nSummary statistic estimations\nABC inference","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Please note that we use a relative path called analysis/ to execute the whole pipeline. This path will be relative to the where Julia or the Command-Line Interface is executed.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"The software is prepared to parallelize each pipeline step using Julia using multi-threading computing. You can add the desired number of threads executing -t option when running julia (e.g using 8 cores: julia -t8). Please make some tests in your machine before executing expensive models. It is almost mandatory to parallelize at least the rate estimations.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"The following examples were tested using a laptop with the following hardware:","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Intel i7-7700HQ (8) @ 3.800GHz \n16GB RAM DDR4 2400MHz","category":"page"},{"location":"abc/#ABC-inference-from-empirical-data","page":"ABC inference","title":"ABC inference from empirical data","text":"","category":"section"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. Remember you need to install ABCreg before continue. Please check home page to install ABCreg.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"It is possible to perform the inference through Julia. We set the tolerance value such that 2500 acceptances were recorded for the inference","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"posteriors = MKtest.ABCreg(analysis_folder=\"analysis/\",S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"The function will output one file per dataset containing the posteriors distributions. The posterior distributions contains five columns corresponding to:","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα: Adaptation rate\nγ: Negative selection coefficient\nβ: DFE shape parameter","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"You can check multiple statistics from posteriors distribution using MKtest.summary_abc function. Please check MKtest.summary_abc, you can approximate the inference using different statistics such as the mode, the mean or the median from posterior.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"df_summary, parameter_inference = MKtest.summary_abc(posteriors)","category":"page"},{"location":"cli/#Command-Line-Interface","page":"Command-Line interface","title":"Command-Line Interface","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We develop a Command-Line Interface (CLI) in case you want to avoid Julia interpreter. You can easly download abcmk_cli.jl. The CLI have different functions to perform the whole pipeline as explained in Infering the rate and strength of adaptation section","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl  ","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"See --help of each command for usages  \n  rates  \n  summaries  \n  abc","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To reproduce the examples you can follow the steps described at Empirical estimation section","category":"page"},{"location":"cli/#Estimate-rates","page":"Command-Line interface","title":"Estimate rates","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To perform the rate estimations you can use the function rates at the CLI. The function works simirarly to the function MKtest.rates. You can check the argument at Rates sectino or using the macro @doc MKtest.rates in the Julia interpreter.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abcmk_cli.jl rates --help\nFunction to solve analytical fixation rates and the expected SFS. The function will create N random models from prior values. Use the arguments to defined the input range for each parameter.\n\nIf rho and/or theta are not set, default values will be used (0.001).\n\nTo parallelize the estimations please be sure you start up Julia using –threads/-t option and set the number of cores.\n\nThe function returns a HDF5 file containing models solved and rates. The rates will be used to compute summary statistics required at ABC.\n\nPlease check the documentation to get more info about models parameters or detailed arguments description https://jmurga.github.io/MKtest.jl/dev/cli/ to check model\n\nPositional Arguments:\n  N: Int64\n  samples: Int64\n  iterations: Int64\n\nOptional Arguments:\n  --alpha: String (default: 0.1,0.9)\n  --gam-dfe: String (default: -1000,-200)\n  --gam-flanking: String (default: -1000,-500)\n  --gL: String (default: 5,10)\n  --gH: String (default: 400,1000)\n  --dac: String (default: 1,2,4,5,10,20,50,100,200,400,500,661,925,1000)\n  --shape: Float64 (default: 0.184)\n  --rho: Float64 (default: 0.001)\n  --theta: Float64 (default: 0.001)\n  --cutoff: String (default: 0.0,1.0)\n  --output: String (default: rates.jld2)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abcmk_cli.jl rates 10000 661 100000 --alpha 0.1,0.9 --gam-dfe -1000,-200 --gam-flanking -1000,-500 --gL 1,10 --gH 200,2000 --output analysis/rates_cli.jld2","category":"page"},{"location":"cli/#Estimate-summary-statistics","page":"Command-Line interface","title":"Estimate summary statistics","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To estimate summary statistics, we used the estimated analytical rates and empirical data following the description at section Empirical estimation.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli summaries --help\nEstimate summary statistics using observed data and analytical rates.\n\nPositional Arguments:\n  N: Int64\n  samples: Int64\n  data: String\n\nOptional Arguments:\n  --genes: String (default: <genes.txt>)\n  --dac: String (default: 2,4,5,10,20,50,200,661,925)\n  --cutoff: String (default: 0.0,1.0)\n  --rates: String (default: rates.jld2)\n  --folder: String (default: <folder>)\n  --summsize: Int64 (default: 100000)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl summaries --folder analysis/ --rates analysis/rates.jld2 --samples 661 --dac 2,4,5,10,20,50,200,661,925 --summsize 1000000","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"The function will output observed data (alphas_N.txt) and summary statistics (summaries_N.txt) in the selected folder. These file will be used at ABC inference to generate posterior distributions.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl summaries --analysis_folder analysis/ --rates  analysis/rates.jld2 --samples 661 --replicas 100 --summstatSize 100000 --dac 2,4,5,10,20,50,200,661,925","category":"page"},{"location":"cli/#Perform-ABC-inference","page":"Command-Line interface","title":"Perform ABC inference","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. Remember you need to install ABCreg before continue. Please check home page to install ABCreg.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"It is possible to perform the inference through Julia. The function will output one file per bootstrapped replicas containing the posteriors distributions. We set the tolerance value to record 1000 values for the regression.  The posterior distributions contains five columns corresponding to:","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα weak: Adaptation rate\nγ: Negative selection coefficient\nβ: Negative selection coefficient","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl abc --help\n\nPositional Arguments:\n  nsumm: Int64\n  tol: Float64\n\nOptional Arguments:\n  --folder: String (default: <folder>)\n  --abcreg: String (default: reg)\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abc 9 0.025 --folder analysis/ --S 9 --abcreg /home/jmurga/ABCreg/src/reg","category":"page"},{"location":"mk/#MK-approaches","page":"MK approaches","title":"MK approaches","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"We included other MK approaches in our module. All the functions use the formated SFS and divergence data described at Summary statistics section.","category":"page"},{"location":"mk/#Standard-MKT","page":"MK approaches","title":"Standard MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The standard McDonald & Kreitman test ([McDonald and Kreitman, 1991]) was developed to be applied to protein coding sequences, combining both divergence (D) and polymorphism (P) sites, and categorizing mutations as synonymous (P_S, D_S) and non-synonymous (P_N, D_N). ","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"If all mutations are either strongly deleterious or neutral, then DiD0 is expected to roughly equal PiP0. In contrast, if positive selection is operating in the region, adaptive mutations rapidly reach fixation and contribute more to divergence than polymorphism compared to neutral mutations, and then DiD0  PiP0. Assuming that adaptive mutations contribute little to polymorphism but substantially to divergence, the proportion of non-synonymous substitutions is inferred following Smith and Eyre-Walker (2002).","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_NP_ScdotfracD_SD_N)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.standardMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")\n\nmk = MKtest.standardMK(sfs[1],divergence[1])","category":"page"},{"location":"mk/#Fay,-Waycoff-and-Wu-MK-extension","page":"MK approaches","title":"Fay, Waycoff and Wu MK extension","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Fay et al. (2002) proposed an approach that removes all polymorphisms segregating at a frequency (j) below a given threshold (usually j  515). Although there is no consensus about what this threshold should be used, J. Charlesworth & Eyre-Walker (2008) demonstrated that  estimates are robust using a frequency threshold of 15%, below which most slightly deleterious polymorphisms are found and removed. The estimates are reasonably accurate only when the rate of adaptive evolution is high and the Distribution of Fitness Effects (DFE) of deleterious mutations is leptokurtic.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_N (j15)P_S (j15)cdotfracD_SD_N)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.fwwMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"fww = MKtest.fwwMK(adap,sfs[1],divergence[1],cutoff=0.15)","category":"page"},{"location":"mk/#imputed-MKT-(in-preparation)","page":"MK approaches","title":"imputed MKT (in preparation)","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The imputed MKT (impMKT) is a modification of the Fay, Waycoff, and Wu MK extension (fwwMK) (Fay et al. (2002) to improve gene-by-gene analyses. The method propose the imputation of slightly deleterious mutations at the SFS rather than removing all variants below a frequency threshold. The imputedMK aims to maximize the information to test the excess of divergence ratio relative to polymorphism at the gene level.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_imputed = 1 - left( fracP_N - P_wdP_S cdot fracD_ND_S right)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"where P_wd is","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"P_wd approx P_wd (j  15) = P_N (j15) - fracP_N (j15)  cdot P_S (j15)P_S (j15)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.imputedMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"imputed = MKtest.imputedMK(adap,sfs[1],divergence[1],cutoff=0.15)","category":"page"},{"location":"mk/#Asymptotic-MKT","page":"MK approaches","title":"Asymptotic MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Proposed by Messer and Petrov (2013). This extension is robust to the presence of selective sweeps (genetic hitchhiking) and the segregation of slightly deleterious polymorphisms substitutions (BGS). In this approach, the authors defined alpha as a function that depends on the SFS of alleles. Therefore, alpha is estimated in different frequency intervals (x), and these values are then adjusted to an exponential function. An exponential fit is suitable as the non-synonymous allele frequency is expected to decay exponentially over the respective levels of synonymous polymorphisms (Messer & Petrov, 2013).","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_fit(x) = a+b cdot e^-cx","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.aMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"amk, ci, model = MKtest.aMK(adap,alpha[1])","category":"page"},{"location":"mk/#Grapes","page":"MK approaches","title":"Grapes","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Grapes is a ML method that can estimate the expected proportion of adaptive fixations given the inferred DFE from the MK data. Grapes assumes can model the DFE in the form of two different versions of the Fisher's geometric model, and a model assuming a Beta-shaped distribution of weak effect mutations, a Gamma distribution as well as a exponential distibution. Please check (Grapes repository)[https://github.com/BioPP/grapes] a cite (Galtier 2016)[https://doi.org/10.1371/journal.pgen.1005774] if you use MKtest.grapes function.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"grapes_df = grapes(sfs,divergence,m,\"GammaExpo\",\"analysis/\",20)","category":"page"},{"location":"reference/#Model-parameters","page":"Reference","title":"Model parameters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"adap is the only variable exported from MKtest module. It is a Mutable structure contaning the variables required to solve the analytical approach. Any value can be easly changed. Remember adap should be change before the execution, in other case, alpha_(x) will be solve with the default values. To change all the values at once, you can use MKtest.parameters in order to set specific models in a new variable.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parameters\nMKtest.analytical_alpha\nMKtest.Br\nMKtest.set_θ\nMKtest.binom_op\nMKtest.Φ","category":"page"},{"location":"reference/#MKtest.parameters","page":"Reference","title":"MKtest.parameters","text":"Mutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. You should declare a mutable structure to the perform the analytical estimations.\n\nParameters\n\ngam_flanking::Int64: Selection coefficient for deleterious alleles\ngL::Int64: Selection coefficient for weakly benefical alleles\ngH::Int64: Selection coefficient for strongly benefical alleles\nal_low::Float64: Proportion of α due to weak selection\nal_tot::Float64: α\nθ_flanking::Float64: Mutation rate defining BGS strength\nθ_coding::Float64: Mutation rate on coding region\nal::Float64: DFE shape parameter \nbe::Float64: DFE scale parameter\nB::Float64: BGS strength\nB_bins::Array{Float64,1}: BGS values to simulate\nppos_l::Float64: Fixation probabily of weakly beneficial alleles\nppos_h::Float64: Fixation probabily of strongly beneficial alleles\nN::Int64: Population size\nn::Int64: Sample size\nLf::Int64: Flanking region length\nρ::Float64: Recombination rate\nTE::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#MKtest.analytical_alpha","page":"Reference","title":"MKtest.analytical_alpha","text":"analytical_alpha(param)\n\nAnalytical α(x) estimation. Solve α(x) generally. We used the expected fixation rates and SFSto approach the asympotic value accouting for background selection, weakly and strong positive selection. α(x) can be estimated taking into account the role of positive selected alleles or not. In this way we explore the role of linkage to deleterious alleles in the coding region.\n\nmathbbEalpha_x =  1 - left(fracmathbbED_smathbbED_NfracmathbbEP_NmathbbEP_Sright)\n\nArguments\n\nparam::parameters\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64}}: α(x) accounting for weak adaptation, α(x) non-accouting for weak adaptation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Br","page":"Reference","title":"MKtest.Br","text":"Br(Lmax,theta)\n\nExpected reduction in nucleotide diversity. Explored at Charlesworth B., 1994:\n\nfracpipi_0 = e^frac4mu L2rL+t\n\nArguments\n\nparam::parameters\ntheta::Float64\n\nReturns\n\nFloat64: expected reduction in diversity given a non-coding length, mutation rate and defined recombination.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.binom_op","page":"Reference","title":"MKtest.binom_op","text":"binom_op(param)\n\nBinomial convolution to sample the allele frequencies probabilites depending on background selection values and sample size.\n\nArguments\n\nparam::parameters\nbinom::binomialDict\n\nReturns\n\nArray{Float64,2}: convoluted SFS for each B value defined in the model (param.B_bins). The estimations are saved at convolutedBn.bn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Φ","page":"Reference","title":"MKtest.Φ","text":"Φ(param,s)\n\nReduction in fixation probabilty due to background selection and linkage. The formulas used have been subjected to several theoretical works (Charlesworth B., 1994, Hudson et al., 1995, Nordborg et al. 1995, Barton NH., 1995).\n\nThe fixation probabilty of selected alleles are reduce by a factor phi:\n\nphi(ts) = e^frac-2mut(1+fracrLt+frac2st)\n\nMultiplying across all deleterious linkes sites, we find:\n\nPhi = prod_1^L = phi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nphi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\ngamma::Int64: selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest-estimation","page":"Reference","title":"MKtest estimation","text":"","category":"section"},{"location":"reference/#Fixations","page":"Reference","title":"Fixations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.fix_neut\nMKtest.fix_neg\nMKtest.p_fix\nMKtest.fix_pos_sim","category":"page"},{"location":"reference/#MKtest.fix_neut","page":"Reference","title":"MKtest.fix_neut","text":"fix_neut(parameters)\n\nExpected neutral fixations rate reduce by B value.\n\nmathbbED_s = (1 - p_- - p_+) B frac12N\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\n\nReturns\n\nFloat64: expected rate of neutral fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fix_neg","page":"Reference","title":"MKtest.fix_neg","text":"fix_neg(parameters,ppos)\n\nExpected fixation rate from negative DFE.\n\nmathbbED_n- =  p_-left(2^-alphabeta^alphaleft(-zetaalphafrac2+beta2 + zetaalpha12(2-frac1N+beta)right)right)\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of fixations from negative DFE.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.p_fix","page":"Reference","title":"MKtest.p_fix","text":"p_fix(parameters,gam)\n\nExpected positive fixation rate.\n\nmathbbED_n+ =  p_+ cdot B cdot (1 - e^(-2s))\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ngam::Int64: positive selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fix_pos_sim","page":"Reference","title":"MKtest.fix_pos_sim","text":"fix_pos_sim(parameters,gamma,ppos)\n\nExpected positive fixations rate reduced due to the impact of background selection and linkage. The probabilty of fixation of positively selected alleles is reduced by a factor Φ across all deleterious linked sites Analytical.Φ.\n\nmathbbED_n+ =  Phi cdot mathbbED_n+\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ngam::Int64: positive selection coefficient.\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polymorphism","page":"Reference","title":"Polymorphism","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.sfs_neut\nMKtest.sfs_pos\nMKtest.sfs_neg\nMKtest.cumulative_sfs\nMKtest.reduce_sfs","category":"page"},{"location":"reference/#MKtest.sfs_neut","page":"Reference","title":"MKtest.sfs_neut","text":"sfs_neut(param,binom)\n\nExpected rate of neutral allele frequency reduce by backgrou\tnd selection. The spectrum depends on the number of individual []\n\nmathbbEPs_(x) = sumx^*=xx^*=1f_B(x)\n\nInput\n\nparam::parameters: mutable structure containing the model.\nSparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nVector{Float64}: expected rate of neutral alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_pos","page":"Reference","title":"MKtest.sfs_pos","text":"sfs_pos(param,s,p,binom)\n\nExpected rate of positive selected allele frequency reduce by background selection. The spectrum depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model.\ns::Int64: selection coefficient.\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected positive selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_neg","page":"Reference","title":"MKtest.sfs_neg","text":"sfs_neg(param,p,binom)\n\nExpected rate of positive selected allele frequency reduce by background selection. Spectrum drawn on a gamma DFE. It depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected negative selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.cumulative_sfs","page":"Reference","title":"MKtest.cumulative_sfs","text":"cumulative_sfs(sfs_tmp)\n\nChanging SFS considering all values above a frequency x. The original aMK approach takes Pn(x) and Ps(x) as the number of polymorphic sites at frequency x rather than above x, but this approach scales poorly as sample size increases. We define the polymorphic spectrum as stated above since these quantities trivially have the same asymptote but are less affected by changing sample size.\n\nArguments\n\nsfs_tmp::Union{Array,SubArray}: SFS vector.\nfreqs::Bool: true/false wheter the input SFS vector containing a first columns with the frequencies.\n\nOutput\n\nVector{Float64}: SFS vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.reduce_sfs","page":"Reference","title":"MKtest.reduce_sfs","text":"reduce_sfs(sfs_tmp,bins)\n\nFunction to reduce the SFS into N bins.\n\nArguments\n\nsfs_tmp::Vector{Float64}: SFS vector.\nbins::Int64: bin size to collapse the SFS.\n\nOutput\n\nVector{Float64}: Binned SFS vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rates","page":"Reference","title":"Rates","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.rates","category":"page"},{"location":"reference/#MKtest.rates","page":"Reference","title":"MKtest.rates","text":"rates(param,gH,gL,gam_flanking,gam_dfe,alpha,iterations,output)\n\nFunction to solve randomly N scenarios. The function will create N models, defined by MKtest.parameters(), to solve analytically fixation rates and the expected SFS for each model. The rates will be used to compute summary statistics required at ABC inference. The function output a HDF5 file containing the solved models, the selected DAC and the analytical solutions. \n\nArguments\n\nparam::parameters: mutable structure containing the model.\ngH::Array{Int64,1}: Range of strong selection coefficients.\ngL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients.\ngam_flanking::Array{Int64,1}: Range of deleterious selection coefficients at the flanking region.\ngam_dfe::Array{Int64,1}: Range of deleterious selection coefficients at the coding region.\nalpha::Vector{Float64}: Range of α value to solve.\niterations::Int64: Number of solutions.\noutput::String: File to output HDF5 file.\n\nReturns\n\nDataFrame: models solved.\nOutput: HDF5 file containing models solved and rates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Summary-statistics","page":"Reference","title":"Summary statistics","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.poisson_fixation\nMKtest.poisson_polymorphism\nMKtest.sampling_summaries\nMKtest.summary_statistics","category":"page"},{"location":"reference/#MKtest.poisson_fixation","page":"Reference","title":"MKtest.poisson_fixation","text":"poisson_fixation(observed_values,λds, λdn)\n\nDivergence sampling from Poisson distribution. The expected neutral and selected fixations are subset through their relative expected rates (fix_neut, fix_neg_b, fix_pos_sim). Empirical values are used are used to simulate the locus L along a branch of time T from which the expected Ds and Dn raw count estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily given the success rate lambda in the distribution.\n\nmathbbED_N = X in Poissonleft(lambda = D times leftfracmathbbED_+ + mathbbED_-mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nmathbbED_S = X in Poissonleft(lambda = D times leftfracmathbbED_0mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nArguments\n\nobserved_values::Array: Array containing the total observed divergence.\nλds::Float64: expected neutral fixations rate.\nλdn::Float64: expected selected fixations rate.\n\nReturns\n\nArray{Int64,1} containing the expected count of neutral and selected fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.poisson_polymorphism","page":"Reference","title":"MKtest.poisson_polymorphism","text":"poisson_polymorphism(observed_values,λps,λpn)\n\nPolymorphism sampling from Poisson distributions. The total expected neutral and selected polimorphism are subset through the relative expected rates at the frequency spectrum (fix_neut, sfs_neut,). Empirical sfs are used to simulate the locus L along a branch of time T from which the expected Ps and Pn raw count are estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily from the whole sfs given each frequency success rate lambda in the distribution.\n\nThe success rate managing the Poisson distribution by the observed count each frequency.  We considered both sampling variance and process variance is affecting the number of variable alleles we sample from SFS. This variance arises from the random mutation-fixation process along the branch. To incorporate this variance we do one sample per frequency-bin and use the total sampled variation and the SFS for the summary statistics.\n\nmathbbEP_N   = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_+(x) + mathbbEP_-(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nmathbbEP_S = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_0(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nArguments\n\nobserved_values::Array{Int64,1}: Array containing the total observed divergence.\nλps::Array{Float64,1}: expected neutral site frequency spectrum rate.\nλpn::Array{Float64,1}: expected selected site frequency spectrum rate.\n\nReturns\n\nArray{Int64,2} containing the expected total count of neutral and selected polymorphism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sampling_summaries","page":"Reference","title":"MKtest.sampling_summaries","text":"sampled_alpha(observed_values,λds, λdn)\n\nOuput the expected values from the Poisson sampling process. Please check poisson_fixation and poisson_polymorphism to understand the samplingn process. α(x) is estimated through the expected values of Dn, Ds, Pn and Ps.\n\nArguments\n\nparam::parameters: Array containing the total observed divergence.\nd::Array: observed divergence.\nafs::Array: observed polymorphism.\nλdiv::Array{Float64,2}: expected fixations rate.\nλdiv::Array{Float64,2}: expected site frequency spectrum rates.\n\nReturns\n\nαsummaries,expdn,expds,exppn,exp_ps,ssAlpha\n\nArray{Int64,2} containing α(x) values.\nArray{Int64,1} expected non-synonymous divergence.\nArray{Int64,1} expected synonymous divergence.\nArray{Int64,1} expected non-synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,2} containing α(x) binned values.\n\nsampling_summaries(gammaL,gammaH,ppos_l,ppos_h,observedData,nopos)\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_statistics","page":"Reference","title":"MKtest.summary_statistics","text":"summary_statistics(param,h5_file,sfs,divergence,analysis_folder,summstat_size)\n\nEstimate summary statistics using observed data and analytical rates. analysis_folder will check for the SFS and divergence file and will be used to output summary statistics\n\nArguments\n\nparam::parameters : Mutable structure containing the models\nh5_file::String : HDF5 containing solved models, fixation and polymorphic rates\nsfs::Vector: SFS data parsed from parse_sfs().\ndivergence::Vector: divergence data from parse_sfs().\nanalysis_folder::String : path to save summary statistics and observed data.\nsummstat_size::Int64 : number of summary statistics to sample.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inference-tools","page":"Reference","title":"Inference tools","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parse_sfs\nMKtest.ABCreg\nMKtest.summary_abc","category":"page"},{"location":"reference/#MKtest.parse_sfs","page":"Reference","title":"MKtest.parse_sfs","text":"parse_sfs(param;data,gene_list,sfs_columns,div_columns,m_columns,bins,isolines)\n\nFunction to parse polymorphism and divergence by subset of genes. The input data is based on supplementary material described at Uricchio et al. 2019. Please be sure the file is tabulated.\n\nGeneId Pn DAF seppareted by commas Ps DAF separated by commas Dn Ds\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ndata::S: path to polymorphic and divergence raw data.\ngene_list:S: path to gene list. \nsfs_columns::Vector{Int64}: column numbers corresponding to Pn and Ps frequencies. Default values [3,5]\ndiv_columns::Vector{Int64}: column numbers corresponding to Dn and Ds frequencies. Default values [6,7]\nm_columns::Vector{Int64}: column numbers corresponding to total number of non-synonymous and synonymous sites. Not require at data. Default values [7,8]\nbins::Union{Nothing,Int64}: size to bin the SFS independtly of the sample size.\n\nReturns\n\nVector{Vector{Float64}}: α_x values. Estimated using the cumulative SFS\nVector{Matrix{Float64}}: Site Frequency Spectrum (non-cumulative)\nVector{Matrix{Int64}}: Synonymous and non-synonymous divergence counts\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.ABCreg","page":"Reference","title":"MKtest.ABCreg","text":"ABCreg(analysis_folder, S, P, tol, abcreg)\n\nPerforming ABC inference using ABCreg. Please, be sure the input folder contain the observed and summary statistics produced by MKtest.summary_statistics().\n\nArguments\n\nanalysis_folder::String : folder containing the observed data and summary estatistics. It will be used to output the posterior distributions\nP::Int64 : number of parameters to infer.\nS::Int64 : number of summary stastitics to perform the inference.\ntol::Float64 : tolerance value. It defines the number of accepted values at ABC inference.\nabcreg::String : path to ABCreg binary.\n\nOutput\n\nposteriors:Vector{Matrix{Float64}}: posteriors distributions estimated by ABCreg.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_abc","page":"Reference","title":"MKtest.summary_abc","text":"summary_abc(posteriors,stat)\n\nPosterior distributions statistics. The function estimates Min., 0.5% Perc., Median, Mean, Mode, \"99.5% Perc., Max values. The mode is estimated following R package abc mode function. The argument stat define the output estimation.\n\nArguments\n\nposterior::Matrix{Float64} : posterior distribution.\nstat::String: output estimation.\nplot_path{String,Nothing}: path to save posterior plot.\n\nOutput\n\nDataFrame: posterior statistics.\nDataFrame: chosen statistic inference.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest","page":"Reference","title":"MKtest","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.aMK\nMKtest.imputedMK\nMKtest.fwwMK\nMKtest.standardMK\nMKtest.grapes","category":"page"},{"location":"reference/#MKtest.aMK","page":"Reference","title":"MKtest.aMK","text":"aMK(param,α;dac_rm,na_rm)\n\nFunction to estimate the asymptotic value of α(x).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\nα::Matrix{Float64}: α(x) values.\ndac_rm::Bool: Remove any value not selected at param.dac.\nna_rm::Bool: Remove any NA value at α(x)\n\nReturns\n\nTuple{Float64, Vector{Float64}, Vector{Float64}}: Tuple containing aMK estimation, CI estimation, model output.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.imputedMK","page":"Reference","title":"MKtest.imputedMK","text":"imputedMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the imputedMK (https://doi.org/10.1093/g3journal/jkac206).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix{Float64}: SFS data parsed from parse_sfs().\ndivergence::Matrix{Int64}: divergence data from parse_sfs().\ncutoff{Float64}: frequency cutoff to perform imputedMK.\nm::Matrix{Int64}: total number of sites parsed from parse_sfs()\n\nReturns\n\n`Dict: Dictionary containing imputedMK estimation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fwwMK","page":"Reference","title":"MKtest.fwwMK","text":"fwwMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the fwwMK (https://doi.org/10.1038/4151024a).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix{Float64}: SFS data parsed from parse_sfs().\ndivergence::Matrix{Int64}: divergence data from parse_sfs().\ncutoff{Float64}: frequency cutoff to perform imputedMK.\nm::Matrix{Int64}: total number of sites parsed from parse_sfs()\n\nReturns\n\n`Dict: Dictionary containing imputedMK estimation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.standardMK","page":"Reference","title":"MKtest.standardMK","text":"standardMK(sfs,divergence;m)\n\nFunction to estimate the original α value.\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\nm::Union{Nothing,Array}: non-synonymous and synonymous sites# Returns\n\nOutput\n\n`Dict: Dictionary containing results\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.grapes","page":"Reference","title":"MKtest.grapes","text":"grapes(sfs,divergence,m,model,folder,bins)\n\nRun grapes using SFS and divergence data. The function will install grapes using Conda from genomedk channel. \n\nArguments\n\nsfs::Vector{Matrix{Float64}}: SFS data parsed from MKtest.parse_sfs()\ndivergence::Vector{Matrix{Int64}}: divergence data parsed from MKtest.parse_sfs()\nm::Vector{Matrix{Int64}}: total number of sites parsed from MKtest.parse_sfs()\nmodel::String: grapes model.\nfolder::String: output folder.\nbins::Int64:  bin size to reduce the SFS. Grapes became unstable when inputing large SFS.\n\nOutput\n\nDataFrame: grapes model estimation.\n\n\n\n\n\n","category":"function"},{"location":"summstat/#Summary-statistics","page":"Summary statistics","title":"Summary statistics","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"To estimate summary statistics, we will used the estimated expected fixation rates and frequency spectra as well as empirical data.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The module includes functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019).","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Please to parse raw data into SFS and divergence counts, first download raw files deposited in our repository:  ","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"TGP\nDGN Zambia population  \nDGN Raleigh population  ","category":"page"},{"location":"summstat/#Parsing-genomic-data","page":"Summary statistics","title":"Parsing genomic data","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Once you have downloaded the files, you can use the function MKtest.parse_sfs to convert the data into SFS and divergence counts. Please check MKtest.parse_sfs to get more info or execute:","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"analysis/tgp.txt\")\n\nadap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"It is possible to directly subset genes IDs using the same ids deposited at you data. You can use a (column list file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembllist.txt] or (CSV-like file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/testnonVIPs.txt] to subset the file list. If you use CSV-like each row will be parsed independtly.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembl_list.txt\",\"analysis/ensembl_list.txt\")\n\nalpha, sfs, divergence = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/ensembl_list.txt\")","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/example_bootstrap.txt\",\"analysis/example_bootstrap.txt\")\n\n# In our case, eachrow is a bootstrapped set\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/example_bootstrap.txt\")","category":"page"},{"location":"summstat/#Estimating-summary-statistics","page":"Summary statistics","title":"Estimating summary statistics","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Once you have the SFS and divergence data variable you can compute the summary statistic. To do it declare a model specifying the sample size corresponding to your data as well as the cutoff used to estimate the rates.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"adap = MKtest.parameters(N=10000,n=661,dac=[2,4,5,10,20,50,200,661,925],cutoff=[0.0,1.0])","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Note you can only input DAC already estimated, nonetheles you can perform any subset from the estimated DAC. To check the estimated DAC you can follow the hierarchy of the hdf5 file.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using JLD2\n# Check hierarchy\nh5   = jldopen(\"analysis/rates.jld2\")\nh5\n\nJLDFile /home/jmurga/analysis/rates.jld2 (read-only)\n └─📂 10000\n    └─📂 661\n       └─📂 cutoff=[0.0,1.0]\n          ├─🔢 models\n          ├─🔢 neut\n          ├─🔢 sel\n          ├─🔢 dsdn\n          └─🔢 dac","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"# Checking estimated dac, string pattern inside the HDF5 variable\nh5[\"10000/661/dac\"]\n\n14-element Vector{Int64}:\n    1\n    2\n    4\n    5\n   10\n   20\n   50\n  100\n  200\n  400\n  500\n  661\n  925\n 1000","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function MKtest.summary_statistics will produce the simulated (summary statistics) and obversed data to run the ABC inference","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"@time df = MKtest.summary_statistics(adap,h5_file=\"analysis/rates.jld2\",sfs=sfs,divergence=divergence,analysis_folder=\"analysis/\",summstat_size=10^5);","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function will create N summary statistic files and the observed data files depending on the length of variables sfs and divergence parsed with MKtest.parse_sfs function (summaries_N.txt and alpha_N.txt respectively, see Data). Both files will be used to perform the ABC inference.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"You can also read any SFS and divergence files using the packages CSV and DataFrames to create the input Vectors. In such case, please be sure that sfs and divergence arguments are of type Vector using square braces ([]) comprehesion","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using CSV, DataFrames\nsfs = CSV.read(\"/path/to/sfs_file.txt\", header=false, DataFrame) |> Matrix\ndivergence = CSV.read(\"/path/to/divergence_file.txt\", header=false, DataFrame) |> Matrix\n\n# Note we modified both variables into a Vector using square braces ([]) comprehesion\n@time df = MKtest.summary_statistics(adap,h5_file=\"analysis/rates.jld2\",sfs=[sfs],divergence=[divergence],analysis_folder=\"analysis/\",summstat_size=10^5);","category":"page"},{"location":"#MKtest.jl","page":"Home","title":"MKtest.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MKtest.jl is a Julia package including a fast Approximate Bayesian Computation version of the McDonald-Kreitman test (ABC-MK) presented in Uricchio et al. (2019). The new ABC-MK implementation significantly improves the efficiency of the population genetics inferences. Following Uricchio et al.(2019), the analytical estimations were used to explore the effect of background selection and selective interference on weakly beneficial alleles. Nonetheless, we developed a more straightforward and computationally efficient ABC-based inference procedure that accounts for the DFE of deleterious and beneficial alleles and partial recombination between selected genomic elements. Our approach estimates alpha, alpha_W, alpha_S, and the Gamma distribution DFE parameters. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, the package automatizes other MK-like analyses parsing polymorphic and divergence data as well as including several extensions such as Grapes, aMK, imputedMK or fwwMK.","category":"page"},{"location":"#Scratch-installation","page":"Home","title":"Scratch installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install our module from scratch, we highly recommend using LTS official Julia binaries. Once you have installed Julia in your system, consider to install some important dependencies to automatize your pipelines. We have prepared a file to install them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"curl -o julia_dependencies.jl https://raw.githubusercontent.com/jmurga/MKtest.jl/master/scripts/julia_dependencies.jl\njulia julia_dependencies.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can easily install our Julia package manually executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(PackageSpec(path=\"https://github.com/jmurga/MKtest.jl\"))'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or from Pkg REPL (by pressing ] at Julia interpreter):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/jmurga/MKtest.jl","category":"page"},{"location":"#ABCreg","page":"Home","title":"ABCreg","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have linked ABCreg with Julia to perform ABC inference. Nonetheless others ABC softwares could be used (like abc (R package) or ABCToolBox). If you are going to use ABCreg to directly make inference from our software please cite the publication and compile it in your system. Anyway, once you get the summary statistic files you can use any other ABC software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ABCreg needs GSL and libz to work. Please install both libraries before compile the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Linux debian-based installation\nsudo apt install libgsl-dev libz-dev build-essential git\n# MacOS installation\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew install GSL zlib git","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/molpopgen/ABCreg.git ABCreg\ncd ABCreg/src && make","category":"page"},{"location":"#Docker-installation","page":"Home","title":"Docker installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Docker image is based on Debian and includes all the software needed to run the pipeline. You can access Julia or Jupyter pulling the image from Docker Hub. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please, remember to use julia -t to use multiple threads and parallelize the estimation. Although optional, note that you can run Julia using a pre-compiled image inside docker to avoid package loading latency. To save the results, you can link the folder /analysis with any folder in your ${HOME} directory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MYPATH=\"/home/jmurga/temporal_analysis/\"\n# Pull the image\ndocker pull jmurga/mktest\n\n# Runninh temporal docker container linking some local volume to export data. Consider to create a container.\n# Using -t 8 to parallelize using 8 threads\n# Using -J mktest.so to avoid loading package latency\ndocker run -it -v --rm ${MYPATH}:/analysis/folder jmurga/mktest julia -t 8 -J mktest.so\n\n# Run jupyter notebook from docker image. Change the port if 8888 is already used\ndocker run -it --rm -v ${MYPATH}:/analysis/folder -p 8888:8888 jmurga/mktest /bin/bash -c \"jupyter-lab --ip='*' --port=8888 --no-browser --allow-root\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use our command-line interface, just run","category":"page"},{"location":"","page":"Home","title":"Home","text":"docker run -it -v ${MYPATH}:/analysis/ jmurga/mktest julia -t 8 -J mktest.so /analysis/abcmk_cli.jl","category":"page"},{"location":"#Singularity-installation","page":"Home","title":"Singularity installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have created a Singularity container to use the software in HPC systems. We have tested the software at HPC working with Slurm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"singularity pull --arch amd64 library://jmurga/default/mktest:latest","category":"page"}]
}
