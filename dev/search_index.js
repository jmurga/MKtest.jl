var documenterSearchIndex = {"docs":
[{"location":"cli/#Command-Line-Interface","page":"Command-Line interface","title":"Command-Line Interface","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We develop a Command-Line Interface (CLI) in case you want to avoid Julia interpreter. You can easly download abcmk_cli.jl. The CLI have different functions to perform the whole pipeline as explained in Infering the rate and strength of adaptation section","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl  ","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"See --help of each command for usages  \n  rates  \n  summaries  \n  abc","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To reproduce the examples you can follow the steps described at Empirical estimation section","category":"page"},{"location":"cli/#Estimate-rates","page":"Command-Line interface","title":"Estimate rates","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To perform the rate estimations you can use the function rates at the CLI. The function works simirarly to the function MKtest.rates. You can check the argument at Rates sectino or using the macro @doc MKtest.rates in the Julia interpreter.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abcmk_cli.jl rates --help\nFunction to solve analytical fixation rates and the expected SFS. The function will create N random models from prior values. Use the arguments to defined the input range for each parameter.\n\nIf rho and/or theta are not set, default values will be used (0.001).\n\nTo parallelize the estimations please be sure you start up Julia using --threads/-t option and set the number of cores.\n\nThe function returns a HDF5 file containing models solved and rates. The rates will be used to compute summary statistics required at ABC.\n\nPlease check the documentation to get more info about models parameters or detailed arguments description https://jmurga.github.io/MKtest.jl/dev/cli/ to check model\n\nPositional Arguments:\n  N: Int64\n  samples: Int64\n  iterations: Int64\n\nOptional Arguments:\n  --alpha: String (default: 0.1,0.9)\n  --gam-dfe: String (default: -1000,-200)\n  --gam-flanking: String (default: -1000,-500)\n  --gL: String (default: 5,10)\n  --gH: String (default: 400,1000)\n  --dac: String (default: 1,2,4,5,10,20,50,100,200,400,500,661,925,1000)\n  --shape: Float64 (default: 0.184)\n  --rho: Float64 (default: 0.001)\n  --theta: Float64 (default: 0.001)\n  --cutoff: String (default: 0.0,1.0)\n  --output: String (default: rates.jld2)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abcmk_cli.jl rates 10000 661 100000 --alpha 0.1,0.9 --gam-dfe -1000,-200 --gam-flanking -1000,-500 --gL 1,10 --gH 200,2000 --output mktest/rates_cli.jld2","category":"page"},{"location":"cli/#Estimate-summary-statistics","page":"Command-Line interface","title":"Estimate summary statistics","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To estimate summary statistics, we used the estimated analytical rates and empirical data following the description at section Empirical estimation.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli summaries --help\nEstimate summary statistics using observed data and analytical rates.\n\nPositional Arguments:\n  N: Int64\n  samples: Int64\n  data: String\n\nOptional Arguments:\n  --genes: String (default: <genes.txt>)\n  --dac: String (default: 2,4,5,10,20,50,200,661,925)\n  --cutoff: String (default: 0.0,1.0)\n  --rates: String (default: rates.jld2)\n  --folder: String (default: <folder>)\n  --summsize: Int64 (default: 100000)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl summaries --folder mktest/ --rates mktest/rates.jld2 --samples 661 --dac 2,4,5,10,20,50,200,661,925 --summsize 1000000","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"The function will output observed data (alphas_N.txt) and summary statistics (summaries_N.txt) in the selected folder. These file will be used at ABC inference to generate posterior distributions.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl summaries --analysis_folder mktest/ --rates  mktest/rates.jld2 --samples 661 --replicas 100 --summstatSize 100000 --dac 2,4,5,10,20,50,200,661,925","category":"page"},{"location":"cli/#Perform-ABC-inference","page":"Command-Line interface","title":"Perform ABC inference","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. Remember you need to install ABCreg before continue. Please check home page to install ABCreg.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"It is possible to perform the inference through Julia. The function will output one file per bootstrapped replicas containing the posteriors distributions. We set the tolerance value to record 1000 values for the regression.  The posterior distributions contains five columns corresponding to:","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα weak: Adaptation rate\nγ: Negative selection coefficient\nβ: Negative selection coefficient","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl abc --help\n\nPositional Arguments:\n  nsumm: Int64\n  tol: Float64\n\nOptional Arguments:\n  --folder: String (default: <folder>)\n  --abcreg: String (default: reg)\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abc 9 0.025 --folder mktest/ --S 9 --abcreg /home/jmurga/ABCreg/src/reg","category":"page"},{"location":"rates/#Estimating-expected-fixation-rates-and-frequency-spectra-considering-generalized-model-of-selection-and-linkage","page":"Rates","title":"Estimating expected fixation rates and frequency spectra considering generalized model of selection and linkage","text":"","category":"section"},{"location":"rates/","page":"Rates","title":"Rates","text":"The first step is to solve N genetic models to obtain the analytical estimations. The process is automatize to create random combination model parameters given priors distributions. The expected fixation rates and frequency spectra, polymorphic rates, and model information will be used to estimate informative summary statistics needed to perform ABC inference. The following section show how to define a genetic a model, input prior distributions and solve the models.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Before executing the rates estimation, start-up Julia using -t/--threads option to add the desired number of threads to parallelize the process.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"julia -t8","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"using MKtest\nmkpath(\"mktest/\")","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"You must to declare a variable containing some basic information about your model using the function MKtest.paramterers. Note that MKtest.parameters contains information about mutation rate, recombination rate, DFE, BGS and probabilities of fixations. To check all the arguments you can access to the function documentation using @doc MKtest.parameter","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@doc MKtest.parameters\n  Mutable structure containing the variables required to solve the analytical\n  approach. All the functions are solve using the internal values of the structure.\n  You should declare a mutable structure to the perform the analytical estimations.\n\n  Parameters\n  ≡≡≡≡≡≡≡≡≡≡≡≡\n\n    •  gam_flanking::Int64: Selection coefficient for deleterious alleles\n\n    •  gL::Int64: Selection coefficient for weakly benefical alleles\n\n    •  gH::Int64: Selection coefficient for strongly benefical alleles\n\n    •  al_low::Float64: Proportion of α due to weak selection\n\n    •  al_tot::Float64: α\n\n    •  θ_flanking::Float64: Mutation rate defining BGS strength\n\n    •  θ_coding::Float64: Mutation rate on coding region\n\n    •  al::Float64: DFE shape parameter\n\n    •  be::Float64: DFE scale parameter\n\n    •  B::Float64: BGS strength\n\n    •  B_bins::Array{Float64,1}: BGS values to simulate\n\n    •  ppos_l::Float64: Fixation probabily of weakly beneficial alleles\n\n    •  ppos_h::Float64: Fixation probabily of strongly beneficial alleles\n\n    •  N::Int64: Population size\n\n    •  n::Int64: Sample size\n\n    •  Lf::Int64: Flanking region length\n\n    •  ρ::Float64: Recombination rate\n\n    •  TE::Float64\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"We will estimate the empirical adaptation rate using TGP data using the estimated DFE parameters at Boyko et al (2008). Hence, we used a sample size of 661 to perform the analysis and the infered deleterious DFE. Note that shape DFE parameter is flexible and modified by a factor of 4 and scale DFE parameter is modified from a prior distribution when executing MKtest.rates function. In addition we will input the selected Derived Alleles Counts (DAC) to later compute summary statistics and perform ABC inference. It is possible to subset any of the selected DAC values when computing summary statistics. If you want to exclude any variant bellow or above a frequency threshold you can use the argument cutoff.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"adap = MKtest.parameters(N=1000,n=661,dac=[1,2,4,5,10,20,50,100,200,400,500,661,925,1000],gam_dfe=-457,shape=0.184,cutoff=[0.0,1.0])","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Now the variable adap contains sample size, DAC and deleterious DFE information. The function MKtest.rates will perform the analytical estimation of N independent models regarding DFE, BGS, mutation rate, and recombination rate. Please note you can edit such values when using MKtest.parameters.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Now you can used the function MKtest.rates to input the prior distributions. The function will randomize the input values to solve N independent estimation regarding our model.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"  rates(param,gH,gL,gam_flanking,gam_dfe,alpha,iterations,output)\n\n  Function to solve randomly N scenarios. The function will create N models,\n  defined by MKtest.parameters(), to solve analytically fixation rates and the\n  expected SFS for each model. The rates will be used to compute summary statistics\n  required at ABC inference. The function output a HDF5 file containing the solved\n  models, the selected DAC and the analytical solutions.\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •  param::parameters: mutable structure containing the model.\n\n    •  gH::Array{Int64,1}: Range of strong selection coefficients.\n\n    •  gL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients.\n\n    •  gam_flanking::Array{Int64,1}: Range of deleterious selection coefficients at the flanking region.\n\n    •  gam_dfe::Array{Int64,1}: Range of deleterious selection coefficients at the coding region.\n\n    •  alpha::Vector{Float64}: Range of α value to solve\n\n    •  iterations::Int64: Number of solutions.\n\n    •  output::String: File to output HDF5 file.\n\n  Returns\n  ≡≡≡≡≡≡≡≡≡\n\n    •  DataFrame: models solved.\n\n    •  Output: HDF5 file containing models solved and rates.\n\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@time df = MKtest.rates(adap,gH=[200,2000],gL=[1,10],gam_dfe=[-2000,-200],gam_flanking=[-1000,-500],iterations = 10^5,output=\"mktest/rates.jld2\");","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The function will create a HDF5 file containing the solved models, the expected fixation rates and frequency spectra, and the selected DAC. This information will be used later to estimate summary statistics.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Note that MKtest.rates is the most resource and time-consuming function. In our case, the function will estimate 10^5 independent models. Each model solves the estimation for all possible BGS values. We used BGS values from 0.1 to 0.999 in 5% increments (defined at adap.B_range). In total, the example will produce 3.7 million estimates. We have used a hierarchical data structure (HDF5) to facilitate model parameters and rates storage. Note that we used re-scale by a factor of 10 adap.N=1000. We explored that the analytical estimations produce similar alpha_(x) values excepting for singletons showing robuts estimations when adap.N is large enough (see cite new ABC-MK). The rates estimation took about 1.5 hours to execute on the hardware described at section Infering the rate and strength of adaptation.","category":"page"},{"location":"mk/#MK-approaches","page":"MK approaches","title":"MK approaches","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"We included other MK approaches in our module. All the functions use the formated SFS and divergence data described at Summary statistics section.","category":"page"},{"location":"mk/#Standard-MKT","page":"MK approaches","title":"Standard MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The standard McDonald & Kreitman test ([McDonald and Kreitman, 1991]) was developed to be applied to protein coding sequences, combining both divergence (D) and polymorphism (P) sites, and categorizing mutations as synonymous (P_S, D_S) and non-synonymous (P_N, D_N). ","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"If all mutations are either strongly deleterious or neutral, then DiD0 is expected to roughly equal PiP0. In contrast, if positive selection is operating in the region, adaptive mutations rapidly reach fixation and contribute more to divergence than polymorphism compared to neutral mutations, and then D_ND_S  P_NP_S. Assuming that adaptive mutations contribute little to polymorphism but substantially to divergence, the proportion of non-synonymous substitutions is inferred following Smith and Eyre-Walker (2002).","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_NP_ScdotfracD_SD_N)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.standardMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"mktest/tgp.txt\")\n\nmk = MKtest.standardMK(sfs[1],divergence[1])","category":"page"},{"location":"mk/#Fay,-Waycoff-and-Wu-MK-extension","page":"MK approaches","title":"Fay, Waycoff and Wu MK extension","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Fay et al. (2002) proposed an approach that removes all polymorphisms segregating at a frequency (j) below a given threshold (usually j  515). Although there is no consensus about what this threshold should be used, J. Charlesworth & Eyre-Walker (2008) demonstrated that  estimates are robust using a frequency threshold of 15%, below which most slightly deleterious polymorphisms are found and removed. The estimates are reasonably accurate only when the rate of adaptive evolution is high and the Distribution of Fitness Effects (DFE) of deleterious mutations is leptokurtic.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_N (j15)P_S (j15)cdotfracD_SD_N)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.fwwMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"fww = MKtest.fwwMK(adap,sfs[1],divergence[1],cutoff=0.15)","category":"page"},{"location":"mk/#imputed-MKT-(in-preparation)","page":"MK approaches","title":"imputed MKT (in preparation)","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The imputed MKT (impMKT) is a modification of the Fay, Waycoff, and Wu MK extension (fwwMK) (Fay et al. (2002) to improve gene-by-gene analyses. The method propose the imputation of slightly deleterious mutations at the SFS rather than removing all variants below a frequency threshold. The imputedMK aims to maximize the information to test the excess of divergence ratio relative to polymorphism at the gene level. alpha is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_imputed = 1 - left( fracP_N - P_wdP_S cdot fracD_ND_S right)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"where P_wd is","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"P_wd approx P_wd (j  15) = P_N (j15) - fracP_N (j15)  cdot P_S (j15)P_S (j15)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.imputedMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"imputed = MKtest.imputedMK(adap,sfs[1],divergence[1],cutoff=0.15)","category":"page"},{"location":"mk/#Asymptotic-MKT","page":"MK approaches","title":"Asymptotic MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Proposed by Messer and Petrov (2013). This extension is robust to the presence of selective sweeps (genetic hitchhiking) and the segregation of slightly deleterious polymorphisms substitutions (BGS). In this approach, the authors defined alpha as a function that depends on the SFS of alleles. Therefore, alpha is estimated in different frequency intervals (x), and these values are then adjusted to an exponential function. An exponential fit is suitable as the non-synonymous allele frequency is expected to decay exponentially over the respective levels of synonymous polymorphisms (Messer & Petrov, 2013). alpha is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_fit(x) = a+b cdot e^-cx","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.aMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"amk, ci, model = MKtest.aMK(adap,alpha[1])","category":"page"},{"location":"mk/#Grapes","page":"MK approaches","title":"Grapes","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Grapes is a ML method that can estimate the expected proportion of adaptive fixations given the inferred DFE from the MK data. Grapes assumes can model the DFE in the form of two different versions of the Fisher's geometric model, and a model assuming a Beta-shaped distribution of weak effect mutations, a Gamma distribution as well as a exponential distibution. Please check (Grapes repository)[https://github.com/BioPP/grapes] a cite (Galtier 2016)[https://doi.org/10.1371/journal.pgen.1005774] if you use MKtest.grapes function.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"grapes_df = grapes(sfs,divergence,m,\"GammaExpo\",\"mktest/\",20)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"We developed an extension of the analytical approximation presented Uricchio et al. (2019). In such a paper, the authors used the analytical approximation to alpha_x to explore the effect of BGS on weakly beneficial alleles, but the empirical estimation of alpha procedure employed was based on computationally intensive forward-in-time simulations. Unfortunately, forward-in-time simulations often require high-performance computing resources and can be prohibitively slow for some models. Here we extend Uricchio et al. (2019)analytical approximations to develop a simple and computationally efficient ABC-based inference procedure modelling the DFE of deleterious and beneficial alleles and incomplete recombination between selected genomic elements. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"We followed a generic ABC scheme (Beaumont et al. (2002)) to perform the empirical estimation of alpha. ABC scheme proceeds by first sampling parameter values from prior distributions, simulating the model using these parameter values, calculating informative summary statistics, and comparing the simulated summary statistics to the observed data. Following the standard ABC scheme, we 1) considered N random combinations from prior distributions; 2) solved N independent models to generate informative summary statistics; 3) subset the parameter values producing summary statistics that best match the observed data from an approximate posterior distribution. Additionally, a linear model can be imposed to correct the non-0 distance between the simulated and observed summary statistics.","category":"page"},{"location":"empirical/#Extending-analytical-estimations","page":"Infering the rate and strength of adaptation","title":"Extending analytical estimations","text":"","category":"section"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Uricchio et al. (2019) used the analytical theory to demonstrate the effect of weakly beneficial alleles at alpha_(x). To do that, they solved alpha_(x) through the fixation and polymorphism rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be canceled","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Here, we extended their analytical calculations to generate the summary statistics required at ABC approaches. Thereby we avoided expensive forward simulations. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Considering fixed values of T, L, mu, and fixation rates it is possible to solve analytical alpha_(x) performing the multiplication. However, this requires not only branch length estimations but also explicitly locus length selection which highly increases the order of estimations to solve. To avoid performing branch length estimations in our computation, we assumed that the empirically observed number of fixations should be proportional to the length of the evolutionary branch of interest, T, the locus length L and mutation ration mu. We take the observed total number of fixations (including both nonsynonymous and synonymous sites) as a proxy for the expected number, and then sample weakly deleterious, neutral, and beneficial substitutions proportional to their relative rates for a fixed set of model parameters. The expected number of substitutions for positively selected substitutions is then","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED = X in Poissonleft(lambda = D_observed times (mathbbEd_++mathbbEd_-+mathbbEd_0)right)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"To estimate alpha_(x) we draw the expected values considering each fixation category. We sampled the values in two categories according to the relative rates. Following the same procedure:","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_0mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_N = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_+ + mathbbEd_-mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"It should be noted that both sampling variance and process variance affect the number of variable alleles at any particular allele frequency in a sequencing sample. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"To incorporate that variance we made one sample per frequency-bin given the SFS, we sampled a Poisson distributed number of polymorphic alleles at frequency x relative to their rate given the expected frequency spectra. The expected frequency spectra were downsampled using a binomial (with probability of success given by the frequency beginpmatrix x  2n endpmatrix in a sample of 2n chromosomes) to account for the sampling variance. Considering the random process at each frequency we made credible intervals for future ABC estimations. Otherwise, we would falsely find higher confidence in our parameter estimates. We draw the expected polymorphic values similarly to fixations, considering the SFS and the expected rates.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbEP = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) observed times (mathbbEp_+(x)+mathbbEp_-(x)+mathbbEp_0(x))right)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"It should be noted that we modified the expected SFS and the observed SFS considering each frequency x as the cumulative sum above x. This quantities have the same asymptote but are less affected by changing sample size. Therefore, we scaled better the analysis to sample size since most common alleles at frequencies x have very few polymorphic sites in large samples. This way, we finally transformed alpha_(x) to be depending on the previous frequency bin value, which reflects each frequency category over the expected asymptotic shape. Because of that, alpha_(x) analysis is more robust even in low polymorphic populations.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"We followed the same procedure described above to subset the expected number of fixation taking into account weakly, strong and deleterious fixation rates categories. ","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_W = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_WmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_SmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"In addition, for each model, we retrieve deleterious DFE parameters to perform ABC inference.","category":"page"},{"location":"empirical/#Computational-pipeline","page":"Infering the rate and strength of adaptation","title":"Computational pipeline","text":"","category":"section"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"The following sections describe a pipeline to estimate the empirical adaptation rate (alpha) using whole-genome protein, Viral Interacting Proteins and Non-Viral Interacting Protein data from the TGP. This analysis is similar to the one performed at Uricchio et al. (2019). We divided the pipeline into the following step:","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Expected fixations rates and frequency spectra estimations\nSummary statistic estimations\nABC inference","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Please note that we use a relative path called mktest/ to execute the whole pipeline. This path will be relative to the where Julia or the Command-Line Interface is executed.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"The software is prepared to parallelize each pipeline step using Julia using multi-threading computing. You can add the desired number of threads executing -t option when running julia (e.g using 8 cores: julia -t8). Please make some tests in your machine before executing expensive models. It is almost mandatory to parallelize at least the rate estimations.","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"The following examples were tested using a laptop with the following hardware:","category":"page"},{"location":"empirical/","page":"Infering the rate and strength of adaptation","title":"Infering the rate and strength of adaptation","text":"Intel i7-7700HQ (8) @ 3.800GHz \n16GB RAM DDR4 2400MHz","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"We included a previously developed bootstrap pipeline to compare adaptation levels between case and non-case (control) genes (Enard and Petrov 2020 and Di et al, 2021])","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"To allow the comparision between case and control genes the bootstrap test uses a straightforward control set-building algorithm that adds control genes to a progressively growing control set, in such a way that the growing control set has the same range of values of confounding factors as the tested set of genes of interest. In addition it is possible to control for a minimum distance between case and control genes. ","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"For TGP we included the counfounding dataset used in Di et al., 2021], as well basic gene coordinates information need to performt the bootstrap. The counfounding dataset control for the following genomic factors:","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"Average overall expression in 53 GTEx v7 tissues GTEx Consortium, 2020. We used the log (in base 2) of TPM (Transcripts Per Million).\nExpression (log base 2 of TPM) in GTEx lymphocytes. Expression in immune tissues may impact the rate of sweeps.\nExpression (log base 2 of TPM) in GTEx testis. Expression in testis might also impact the rate of sweeps.\ndeCode recombination rates 50 kb and 500 kb: recombination is expected to have a strong impact on iHS and nSL values, with larger, easier to detect sweeps in low recombination regions but also more false positive sweeps signals. The average recombination rates in the gene-centered windows are calculated using the most recent deCode recombination map Halldorsson et al., 2019. We use both 50 kb and 500 kb window estimates to account for the effect of varying window sizes on the estimation of this confounding factor (same logic for other factors where we also use both 50 kb and 500 kb windows).\nGC content is calculated as a percentage per window in 50 kb and 500 kb windows. It is obtained from the USCS Genome Browser.\nThe density of coding sequences in 50 kb and 500 kb windows centered on genes. The density is calculated as the proportion of coding bases respect to the whole length of the window. Coding sequences are Ensembl v99 coding sequences.\nThe density of mammalian phastCons conserved elements Siepel et al., 2005 (in 50 kb and 500 k windows), downloaded from the UCSC Genome Browser. We used a threshold considering 10% of the genome as conserved, as it is unlikely that more than 10% of the whole genome is constrained according to previous evidence Siepel et al., 2005. Given that each conserved segment had a score, we considered those segments above the 10% threshold as conserved.\nThe density of regulatory elements, as measured by the density of DNASE1 hypersensitive sites (in 50 kb and 500 kb windows) also from the UCSC Genome Browser.\nThe number of protein-protein interactions (PPIs) in the human protein interaction network Luisi et al., 2015. We use the log (base 2) of the number of PPIs.\nThe gene genomic length, that is the distance between the most upstream and the most downstream transcription start sites.\nThe number of gene neighbors in a 50 kb window, and the same number in 500 kb window centered on the focal genes: it is the number of coding genes within 25 kb or within 250 kb.\nThe number of viruses that interact with a specific gene (Enard and Petrov 2020).\nThe proportion of immune genes. The matched control sets have the same proportion of immune genes as disease genes, immune genes being genes annotated with the Gene Ontology terms GO:0002376 (immune system process), GO:0006952 (defense response) and/or GO:0006955 (immune response) as of May 2020 (Gene Ontology Consortium and Gene Ontology, 2021).\nThe average non-synonymous polymorphism rate pN in African populations, and the the synonymous rate pS. We matched pN to build control sets of non-disease genes with the same average amount of strong purifying selection as disease genes. Also, pS can be a proxy for mutation rate and we can build control sets of non-disease genes with similar level of mutation rates.\nMcVicker’s B value which can be used to account for more recent selective constraint (McVicker et al., 2009).","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"To run the bootstrap you must to declare a variable containing some basic information about data and bootstrap options using the function MKtest.bootstrap_parameters. To check all the arguments you can access to the function documentation using @doc MKtest.bootstrap_parameters","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"b_param = MKtest.bootstrap_parameters(data = \"mktest/ensembl_list.txt\", annotation = \"mktest/ensembl_gene_coords_v69.bed\", dist = 1, rep = 3, tol = 0.05, iter = 10, factors = \"mktest/confounding_factors.txt\", output = \"mktest/test\")","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"To run the bootstrap just use MKtest.boostrap function. It will output one file containing the case genes (mktest/test_case.txt) and another containing the control genes (analysis/test_control.txt)","category":"page"},{"location":"bootstrap/","page":"Bootstrap","title":"Bootstrap","text":"MKtest.bootstrap(b_param)","category":"page"},{"location":"summstat/#Summary-statistics","page":"Summary statistics","title":"Summary statistics","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"To estimate summary statistics, we need to used the estimated expected fixation rates and frequency spectra as well as empirical data.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The module includes functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019). Please to parse TGP or DGN raw data into SFS and divergence counts, first download raw files deposited in our repository:  ","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"TGP\nDGN Zambia population  \nDGN Raleigh population  ","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"If you are going to parse DGN, you need to change the value of the argument isoline to true. Following the Murga-Moreno et al. (2019) sample size for each population is:","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Zambia population: 154\nRAL population: 160","category":"page"},{"location":"summstat/#Parsing-genomic-data","page":"Summary statistics","title":"Parsing genomic data","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Once you have downloaded the files, you can use the function MKtest.parse_sfs to convert the data into SFS and divergence counts. Please check MKtest.parse_sfs to get more info or execute:","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"mktest/tgp.txt\")\n\nadap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"mktest/tgp.txt\")","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"It is possible to directly subset genes IDs using the same ids deposited at you data. You can use a (column list file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembllist.txt] or (CSV-like file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/testnonVIPs.txt] to subset the file list. If you use CSV-like each row will be parsed independtly.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembl_list.txt\",\"mktest/ensembl_list.txt\")\n\nalpha, sfs, divergence = MKtest.parse_sfs(adap, data = \"mktest/tgp.txt\",gene_list = \"mktest/ensembl_list.txt\")","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/example_bootstrap.txt\",\"mktest/example_bootstrap.txt\")\n\n# In our case, eachrow is a bootstrapped set\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"mktest/tgp.txt\",gene_list = \"mktest/example_bootstrap.txt\")","category":"page"},{"location":"summstat/#Estimating-summary-statistics","page":"Summary statistics","title":"Estimating summary statistics","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Once you have the SFS and divergence data variable you can compute the summary statistic. To do it declare a model specifying the sample size corresponding to your data as well as the cutoff used to estimate the rates.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"adap = MKtest.parameters(N=1000,n=661,dac=[2,4,5,10,20,50,200,661,925],cutoff=[0.0,1.0])","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Note you can only input DAC already estimated, nonetheles you can perform any subset from the estimated DAC. To check the estimated DAC you can follow the hierarchy of the hdf5 file.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using JLD2\n# Check hierarchy\nh5   = jldopen(\"mktest/rates.jld2\")\nh5\n\nJLDFile /home/jmurga/mktest/rates.jld2 (read-only)\n └─📂 1000\n    └─📂 661\n       └─📂 cutoff=[0.0,1.0]\n          ├─🔢 models\n          ├─🔢 neut\n          ├─🔢 sel\n          ├─🔢 dsdn\n          └─🔢 dac","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"# Checking estimated dac, string pattern inside the HDF5 variable\nh5[\"1000/661/dac\"]\n\n14-element Vector{Int64}:\n    1\n    2\n    4\n    5\n   10\n   20\n   50\n  100\n  200\n  400\n  500\n  661\n  925\n 1000","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function MKtest.summary_statistics will produce the simulated (summary statistics) and obversed data to run the ABC inference","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"@time df = MKtest.summary_statistics(adap,h5_file=\"mktest/rates.jld2\",sfs=sfs,divergence=divergence,analysis_folder=\"mktest/\",summstat_size=10^5);","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function will create N summary statistic files and the observed data files depending on the length of variables sfs and divergence parsed with MKtest.parse_sfs function (summaries_N.txt and alpha_N.txt respectively, see Data). Both files will be used to perform the ABC inference.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"You can also read any SFS and divergence files using the packages CSV and DataFrames to create the input Vectors. In such case, please be sure that sfs and divergence arguments are of type Vector using square braces ([]) comprehesion","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using CSV, DataFrames\nsfs = CSV.read(\"/path/to/sfs_file.txt\", header=false, DataFrame) |> Matrix\ndivergence = CSV.read(\"/path/to/divergence_file.txt\", header=false, DataFrame) |> Matrix\n\n# Note we modified both variables into a Vector using square braces ([]) comprehesion\n@time df = MKtest.summary_statistics(adap,h5_file=\"mktest/rates.jld2\",sfs=[sfs],divergence=[divergence],analysis_folder=\"mktest/\",summstat_size=10^5);","category":"page"},{"location":"reference/#Model-parameters","page":"Reference","title":"Model parameters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"adap is the only variable exported from MKtest module. It is a Mutable structure contaning the variables required to solve the analytical approach. Any value can be easly changed. Remember adap should be change before the execution, in other case, alpha_(x) will be solve with the default values. To change all the values at once, you can use MKtest.parameters in order to set specific models in a new variable.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parameters\nMKtest.analytical_alpha\nMKtest.Br\nMKtest.set_θ\nMKtest.binom_op\nMKtest.Φ","category":"page"},{"location":"reference/#MKtest.parameters","page":"Reference","title":"MKtest.parameters","text":"Mutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. You should declare a mutable structure to the perform the analytical estimations.\n\nParameters\n\ngam_flanking::Int64: Selection coefficient for deleterious alleles\ngL::Int64: Selection coefficient for weakly benefical alleles\ngH::Int64: Selection coefficient for strongly benefical alleles\nal_low::Float64: Proportion of α due to weak selection\nal_tot::Float64: α\nθ_flanking::Float64: Mutation rate defining BGS strength\nθ_coding::Float64: Mutation rate on coding region\nal::Float64: DFE shape parameter \nbe::Float64: DFE scale parameter\nB::Float64: BGS strength\nB_bins::Array{Float64,1}: BGS values to simulate\nppos_l::Float64: Fixation probabily of weakly beneficial alleles\nppos_h::Float64: Fixation probabily of strongly beneficial alleles\nN::Int64: Population size\nn::Int64: Sample size\nLf::Int64: Flanking region length\nρ::Float64: Recombination rate\nTE::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#MKtest.analytical_alpha","page":"Reference","title":"MKtest.analytical_alpha","text":"analytical_alpha(param)\n\nAnalytical α(x) estimation. Solve α(x) generally. We used the expected fixation rates and SFSto approach the asympotic value accouting for background selection, weakly and strong positive selection. α(x) can be estimated taking into account the role of positive selected alleles or not. In this way we explore the role of linkage to deleterious alleles in the coding region.\n\nmathbbEalpha_x =  1 - left(fracmathbbED_smathbbED_NfracmathbbEP_NmathbbEP_Sright)\n\nArguments\n\nparam::parameters\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64}}: α(x) accounting for weak adaptation, α(x) non-accouting for weak adaptation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Br","page":"Reference","title":"MKtest.Br","text":"Br(Lmax,theta)\n\nExpected reduction in nucleotide diversity. Explored at Charlesworth B., 1994:\n\nfracpipi_0 = e^frac4mu L2rL+t\n\nArguments\n\nparam::parameters\ntheta::Float64\n\nReturns\n\nFloat64: expected reduction in diversity given a non-coding length, mutation rate and defined recombination.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.binom_op","page":"Reference","title":"MKtest.binom_op","text":"binom_op(param)\n\nBinomial convolution to sample the allele frequencies probabilites depending on background selection values and sample size.\n\nArguments\n\nparam::parameters\nB_bins::Vector{Float64}\n\nReturns\n\nArray{Float64,2}: convoluted SFS for each B value defined in the model (B_bins). The estimations are saved at convolutedBn.bn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Φ","page":"Reference","title":"MKtest.Φ","text":"Φ(param,s)\n\nReduction in fixation probabilty due to background selection and linkage. The formulas used have been subjected to several theoretical works (Charlesworth B., 1994, Hudson et al., 1995, Nordborg et al. 1995, Barton NH., 1995).\n\nThe fixation probabilty of selected alleles are reduce by a factor phi:\n\nphi(ts) = e^frac-2mut(1+fracrLt+frac2st)\n\nMultiplying across all deleterious linkes sites, we find:\n\nPhi = prod_1^L = phi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nphi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\ngamma::Int64: selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest-estimation","page":"Reference","title":"MKtest estimation","text":"","category":"section"},{"location":"reference/#Fixations","page":"Reference","title":"Fixations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.fix_neut\nMKtest.fix_neg\nMKtest.p_fix\nMKtest.fix_pos_sim","category":"page"},{"location":"reference/#MKtest.fix_neut","page":"Reference","title":"MKtest.fix_neut","text":"fix_neut(parameters)\n\nExpected neutral fixations rate reduce by B value.\n\nmathbbED_s = (1 - p_- - p_+) B frac12N\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\n\nReturns\n\nFloat64: expected rate of neutral fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fix_neg","page":"Reference","title":"MKtest.fix_neg","text":"fix_neg(parameters,ppos)\n\nExpected fixation rate from negative DFE.\n\nmathbbED_n- =  p_-left(2^-alphabeta^alphaleft(-zetaalphafrac2+beta2 + zetaalpha12(2-frac1N+beta)right)right)\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of fixations from negative DFE.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.p_fix","page":"Reference","title":"MKtest.p_fix","text":"p_fix(parameters,gam)\n\nExpected positive fixation rate.\n\nmathbbED_n+ =  p_+ cdot B cdot (1 - e^(-2s))\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ngam::Int64: positive selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fix_pos_sim","page":"Reference","title":"MKtest.fix_pos_sim","text":"fix_pos_sim(parameters,gamma,ppos)\n\nExpected positive fixations rate reduced due to the impact of background selection and linkage. The probabilty of fixation of positively selected alleles is reduced by a factor Φ across all deleterious linked sites Analytical.Φ.\n\nmathbbED_n+ =  Phi cdot mathbbED_n+\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ngam::Int64: positive selection coefficient.\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polymorphism","page":"Reference","title":"Polymorphism","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.sfs_neut\nMKtest.sfs_pos\nMKtest.sfs_neg\nMKtest.cumulative_sfs\nMKtest.reduce_sfs","category":"page"},{"location":"reference/#MKtest.sfs_neut","page":"Reference","title":"MKtest.sfs_neut","text":"sfs_neut(param,binom)\n\nExpected rate of neutral allele frequency reduce by background selection. The spectrum depends on the number of individual []\n\nmathbbEPs_(x) = sumx^*=xx^*=1f_B(x)\n\nInput\n\nparam::parameters: mutable structure containing the model.\nSparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nVector{Float64}: expected rate of neutral alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_pos","page":"Reference","title":"MKtest.sfs_pos","text":"sfs_pos(param,s,p,binom)\n\nExpected rate of positive selected allele frequency reduce by background selection. The spectrum depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model.\ns::Int64: selection coefficient.\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected positive selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_neg","page":"Reference","title":"MKtest.sfs_neg","text":"sfs_neg(param,p,binom)\n\nExpected rate of positive selected allele frequency reduce by background selection. Spectrum drawn on a gamma DFE. It depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected negative selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.reduce_sfs","page":"Reference","title":"MKtest.reduce_sfs","text":"reduce_sfs(sfs_tmp,bins)\n\nFunction to reduce the SFS into N bins.\n\nArguments\n\nsfs_tmp::Vector{Float64}: SFS vector.\nbins::Int64: bin size to collapse the SFS.\n\nOutput\n\nVector{Float64}: Binned SFS vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rates","page":"Reference","title":"Rates","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.rates","category":"page"},{"location":"reference/#MKtest.rates","page":"Reference","title":"MKtest.rates","text":"rates(param,gH,gL,gam_flanking,gam_dfe,alpha,iterations,output)\n\nFunction to solve randomly N scenarios. The function will create N models, defined by parameters(), to solve analytically fixation rates and the expected SFS for each model. The rates will be used to compute summary statistics required at ABC inference. The function output a HDF5 file containing the solved models, the selected DAC and the analytical solutions.\n\nArguments\n\nparam::parameters: mutable structure containing the model.\ngH::Array{Int64,1}: Range of strong selection coefficients.\ngL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients.\ngam_flanking::Array{Int64,1}: Range of deleterious selection coefficients at the flanking region.\ngam_dfe::Array{Int64,1}: Range of deleterious selection coefficients at the coding region.\nalpha::Vector{Float64}: Range of α value to solve.\niterations::Int64: Number of solutions.\noutput_file::String: File to output HDF5 file.\n\nReturns\n\nDataFrame: models solved.\nOutput_file: HDF5 file containing models solved and rates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Summary-statistics","page":"Reference","title":"Summary statistics","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.poisson_fixation\nMKtest.poisson_polymorphism\nMKtest.sampling_summaries\nMKtest.summary_statistics","category":"page"},{"location":"reference/#MKtest.poisson_fixation","page":"Reference","title":"MKtest.poisson_fixation","text":"poisson_fixation(observed_values,λds, λdn)\n\nDivergence sampling from Poisson distribution. The expected neutral and selected fixations are subset through their relative expected rates (fix_neut, fix_neg_b, fix_pos_sim). Empirical values are used are used to simulate the locus L along a branch of time T from which the expected Ds and Dn raw count estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily given the success rate lambda in the distribution.\n\nmathbbED_N = X in Poissonleft(lambda = D times leftfracmathbbED_+ + mathbbED_-mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nmathbbED_S = X in Poissonleft(lambda = D times leftfracmathbbED_0mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nArguments\n\nobserved_values::Array: Array containing the total observed divergence.\nλds::Float64: expected neutral fixations rate.\nλdn::Float64: expected selected fixations rate.\n\nReturns\n\nArray{Int64,1} containing the expected count of neutral and selected fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.poisson_polymorphism","page":"Reference","title":"MKtest.poisson_polymorphism","text":"poisson_polymorphism(observed_values,λps,λpn)\n\nPolymorphism sampling from Poisson distributions. The total expected neutral and selected polimorphism are subset through the relative expected rates at the frequency spectrum (fix_neut, sfs_neut,). Empirical sfs are used to simulate the locus L along a branch of time T from which the expected Ps and Pn raw count are estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily from the whole sfs given each frequency success rate lambda in the distribution.\n\nThe success rate managing the Poisson distribution by the observed count each frequency.  We considered both sampling variance and process variance is affecting the number of variable alleles we sample from SFS. This variance arises from the random mutation-fixation process along the branch. To incorporate this variance we do one sample per frequency-bin and use the total sampled variation and the SFS for the summary statistics.\n\nmathbbEP_N   = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_+(x) + mathbbEP_-(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nmathbbEP_S = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_0(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nArguments\n\nobserved_values::Array{Int64,1}: Array containing the total observed divergence.\nλps::Array{Float64,1}: expected neutral site frequency spectrum rate.\nλpn::Array{Float64,1}: expected selected site frequency spectrum rate.\n\nReturns\n\nArray{Int64,2} containing the expected total count of neutral and selected polymorphism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sampling_summaries","page":"Reference","title":"MKtest.sampling_summaries","text":"sampled_alpha(observed_values,λds, λdn)\n\nOuput the expected values from the Poisson sampling process. Please check poisson_fixation and poisson_polymorphism to understand the samplingn process. α(x) is estimated through the expected values of Dn, Ds, Pn and Ps.\n\nArguments\n\nparam::parameters: Array containing the total observed divergence.\nd::Array: observed divergence.\nafs::Array: observed polymorphism.\nλdiv::Array{Float64,2}: expected fixations rate.\nλdiv::Array{Float64,2}: expected site frequency spectrum rates.\n\nReturns\n\nαsummaries,expdn,expds,exppn,exp_ps,ssAlpha\n\nArray{Int64,2} containing α(x) values.\nArray{Int64,1} expected non-synonymous divergence.\nArray{Int64,1} expected synonymous divergence.\nArray{Int64,1} expected non-synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,2} containing α(x) binned values.\nsamplingsummaries(gammaL,gammaH,pposl,ppos_h,observedData,nopos)\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_statistics","page":"Reference","title":"MKtest.summary_statistics","text":"summary_statistics(param,h5_file,sfs,divergence,output_folder,summstat_size)\n\nEstimate summary statistics using observed data and analytical rates. output_folder will be used to output summary statistics\n\nArguments\n\nparam::parameters : Mutable structure containing the models\nh5_file::String : HDF5 containing solved models, fixation and polymorphic rates\nsfs::Vector: SFS data parsed from parse_sfs().\ndivergence::Vector: divergence data from parse_sfs().\noutput_folder::String : path to save summary statistics and observed data.\nsummstat_size::Int64 : number of summary statistics to sample.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inference-tools","page":"Reference","title":"Inference tools","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parse_sfs\nMKtest.ABCreg\nMKtest.summary_abc","category":"page"},{"location":"reference/#MKtest.parse_sfs","page":"Reference","title":"MKtest.parse_sfs","text":"parse_sfs(param;data,gene_list,sfs_columns,div_columns,l_columns,bins,isolines)\n\nFunction to parse polymorphism and divergence by subset of genes. The input data is based on supplementary material described at Uricchio et al. 2019. Please be sure the file is tabulated.\n\nGeneId Pn DAF seppareted by commas Ps DAF separated by commas Dn Ds\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ndata::S: path to polymorphic and divergence raw data.\ngene_list:S: path to gene list. \nsfs_columns::Vector{Int64}: column numbers corresponding to Pn and Ps frequencies. Default values [3,5]\ndiv_columns::Vector{Int64}: column numbers corresponding to Dn and Ds frequencies. Default values [6,7]\nl_columns::Vector{Int64}: column numbers corresponding to total number of non-synonymous and synonymous sites. Not require at data. Default values [7,8]\nbins::Union{Nothing,Int64}: size to bin the SFS independtly of the sample size.\n\nReturns\n\nVector{Vector{Float64}}: α_x values. Estimated using the cumulative SFS\nVector{Matrix{Float64}}: Site Frequency Spectrum (non-cumulative)\nVector{Matrix{Int64}}: Synonymous and non-synonymous divergence counts\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.ABCreg","page":"Reference","title":"MKtest.ABCreg","text":"ABCreg(output_folder, S, P, tol, abcreg)\n\nPerforming ABC inference using ABCreg. Please, be sure the input folder contain the observed and summary statistics produc  ed by MKtest.summary_statistics().\n\nArguments\n\noutput_folder::String : folder containing the observed data and summary estatistics. It will be used to output the posterior distributions\nP::Int64 : number of parameters to infer.\nS::Int64 : number of summary stastitics to perform the inference.\ntol::Float64 : tolerance value. It defines the number of accepted values at ABC inference.\nabcreg::String : path to ABCreg binary.\n\nOutput\n\nposteriors:Vector{Matrix{Float64}}: posteriors distributions estimated by ABCreg.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_abc","page":"Reference","title":"MKtest.summary_abc","text":"summary_abc(posteriors,stat)\n\nPosterior distributions statistics. The function estimates Min., 0.5% Perc., Median, Mean, Mode, \"99.5% Perc., Max values. The mode is estimated following R package abc mode function. The argument stat define the output estimation.\n\nArguments\n\nposterior::Matrix{Float64} : posterior distribution.\nstat::String: output estimation.\n\nOutput\n\nDataFrame: posterior statistics.\nDataFrame: chosen statistic inference.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest","page":"Reference","title":"MKtest","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.aMK\nMKtest.imputedMK\nMKtest.fwwMK\nMKtest.standardMK\nMKtest.grapes","category":"page"},{"location":"reference/#MKtest.aMK","page":"Reference","title":"MKtest.aMK","text":"aMK(param,α;dac_rm,na_rm)\n\nFunction to estimate the asymptotic value of α(x).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix: SFS data parsed from parse_sfs().\ndivergence::Matrix: divergence data from parse_sfs().\nthreshold{Float64}: frequency cutoff to perform imputedMK.\ncumulative::Bool: Perform α(x) estimation using the cumulative SFS\ndac_rm::Bool: Remove any value not selected at param.dac.\nna_rm::Bool: Remove any NA value at α(x)\n\nReturns\n\nDataFrame\n\n\n\n\n\naMK(param,α;dac_rm,na_rm)\n\nFunction to estimate the asymptotic value of α(x).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Vector: SFS data parsed from parse_sfs().\ndivergence::Vector: divergence data from parse_sfs().\nthreshold{Float64}: frequency cutoff to perform imputedMK.\ncumulative::Bool: Perform α(x) estimation using the cumulative SFS\ndac_rm::Bool: Remove any value not selected at param.dac.\nna_rm::Bool: Remove any NA value at α(x)\n\nReturns\n\nDataFrame\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.imputedMK","page":"Reference","title":"MKtest.imputedMK","text":"imputedMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the imputedMK (https://doi.org/10.1093/g3journal/jkac206).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Vector: SFS data parsed from parse_sfs().\ndivergence::Vector: divergence data from parse_sfs().\nthreshold{Float64}: frequency cutoff to perform imputedMK.\n\nReturns\n\nDataFrame\n\n\n\n\n\nimputedMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the imputedMK (https://doi.org/10.1093/g3journal/jkac206).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix{Float64}: SFS data parsed from parse_sfs().\ndivergence::Matrix{Int64}: divergence data from parse_sfs().\nthreshold{Float64}: frequency cutoff to perform imputedMK.\n\nReturns\n\nDataFrame\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fwwMK","page":"Reference","title":"MKtest.fwwMK","text":"fwwMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the fwwMK (https://doi.org/10.1038/4151024a).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Vector: SFS data parsed from parse_sfs().\ndivergence::Vector: divergence data from parse_sfs().\nthreshold{Float64}: frequency cutoff to perform fwwMK.\n\nReturns\n\nDataFrame\n\n\n\n\n\nfwwMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the fwwMK (https://doi.org/10.1038/4151024a).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix: SFS data parsed from parse_sfs().\ndivergence::Matrix: divergence data from parse_sfs().\nthreshold{Float64}: frequency cutoff to perform fwwMK.\n\nReturns\n\nDataFrame\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.standardMK","page":"Reference","title":"MKtest.standardMK","text":"standardMK(sfs,divergence;m)\n\nFunction to estimate the original α value.\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\n\nOutput\n\nDataFrame\n\n\n\n\n\nstandardMK(sfs,divergence;m)\n\nFunction to estimate the original α value.\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\n\nOutput\n\nDataFrame\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.grapes","page":"Reference","title":"MKtest.grapes","text":"grapes(sfs,divergence,model)\n\nRun grapes using SFS and divergence data. The function will install grapes using Conda from genomedk channel. \n\nArguments\n\nsfs::Vector{Matrix{Float64}}: SFS data parsed from parse_sfs()\ndivergence::Vector{Matrix{Int64}}: divergence data parsed from parse_sfs()\nmodel::String: grapes model (GammaZero, GammaExpo, DisplGamma, ScaledBeta, FGMBesselK and all)\nn::Int64: smaller sample size to project the SFS\nnearly_neutral::Int64: Sadp threshold of above which a mutation is considered adaptive\nFWW_threshold::Float64: minimal allele frequency in FWW α\nnb_rand_start::Int64: number of random starting values in model optimization (default=0); setting positive values will slow down the program but decrease the probability of being trapped in local optima.\nanc_to_rec_Ne_ratio::Float64: divergence/polymorphism Ne ratio\nno_div_data::Bool: only use divergence data to estimate DFE\nno_div_param::Bool: implements so-called [-A] version in Galtier (2016); also called a DFE by Tataru et al. (2017), and indicated with * in Rousselle et al. (2018); irrelevant if model = GammaZero; (default=false)\nno_syn_orient_error::Bool: force equal synonymous and non-synonymous mis-orientation rate(default=false)\nfold::Bool: fold the SFS\nfixed_param::String: this option should be used if one does not want to optimize every parameter, but rather have some parameters fixed to predefined values; parameter names and predefined values are passed via a control file; see example at the bottom of this file (default=none).\n\nOutput\n\nDataFrame: grapes model estimation.\n\n\n\n\n\n","category":"function"},{"location":"abc/#ABC-inference-from-empirical-data","page":"ABC inference","title":"ABC inference from empirical data","text":"","category":"section"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. We used our Julia interface to ABCreg o run the inference. We set the tolerance value such that 2500 acceptances were recorded for the inference","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"posteriors = MKtest.ABCreg(analysis_folder=\"mktest/\",S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"The function will output one file per dataset containing the posteriors distributions. The posterior distributions contains five columns corresponding to:","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα: Adaptation rate\nγ: Negative selection coefficient\nβ: DFE shape parameter","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"You can check multiple statistics from posteriors distribution using MKtest.summary_abc function. Please check MKtest.summary_abc, you can approximate the inference using different statistics such as the mode, the mean or the median from posterior.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"df_summary, parameter_inference = MKtest.summary_abc(posteriors)","category":"page"},{"location":"#MKtest.jl","page":"Home","title":"MKtest.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MKtest.jl is a Julia package including a fast Approximate Bayesian Computation version of the McDonald-Kreitman test (ABC-MK) presented in Uricchio et al. (2019). The new ABC-MK implementation significantly improves the efficiency of the population genetics inferences. Following Uricchio et al.(2019), the analytical estimations were used to explore the effect of background selection and selective interference on weakly beneficial alleles. Nonetheless, we developed a more straightforward and computationally efficient ABC-based inference procedure that accounts for the DFE of deleterious and beneficial alleles and partial recombination between selected genomic elements. Our approach estimates alpha, alpha_W, alpha_S, and the Gamma distribution DFE parameters. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, the package automatizes other MK-like analyses parsing polymorphic and divergence data as well as including several extensions such as Grapes, aMK, imputedMK or fwwMK.","category":"page"},{"location":"#Scratch-installation","page":"Home","title":"Scratch installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install our module from scratch, we highly recommend using LTS official Julia binaries. Once you have installed Julia in your system, consider to install some important dependencies to automatize your pipelines. We have prepared a file to install them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"curl -o julia_dependencies.jl https://raw.githubusercontent.com/jmurga/MKtest.jl/master/scripts/julia_dependencies.jl\njulia julia_dependencies.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can easily install our Julia package manually executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(PackageSpec(path=\"https://github.com/jmurga/MKtest.jl\"))'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or from Pkg REPL (by pressing ] at Julia interpreter):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/jmurga/MKtest.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"To parallelize your estimation please remember to use -t/--threads option when starting Julia. Set -t/threads to auto  to set the threads to the number of CPU threads.You also can export the environment variable JULIA_NUM_THREADS into your .bashrc to avoid thread indication when starting Julia. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -t 8\n# or\njulia -t auto\n# or\nprintf \"\\nexport JULIA_NUM_THREADS=8\\n\" >> ~/.bashrc && source ~/.bashrc","category":"page"},{"location":"","page":"Home","title":"Home","text":"To check the number of avaibles threads you can run the command Threads.nthreads() into your Julia session","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia still have some latency problem loading packages. Please consider to create a custom sysimages for reduced latency. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"curl -o mktest/julia_dependencies.jl https://raw.githubusercontent.com/jmurga/MKtest.jl/master/scripts/precompile_mktest.jl \njulia -e 'using PackageCompiler;PackageCompiler.create_sysimage(:MKtest, sysimage_path=\"/mktest/mktest.so\", precompile_execution_file=\"mktest/precompile_mktest.jl\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can run the sysimage using -J option when starting Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -t8 -J mktest/mktest.so","category":"page"},{"location":"#ABCreg","page":"Home","title":"ABCreg","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have linked ABCreg with Julia to perform ABC inference. Nonetheless others ABC softwares could be used (like abc (R package) or ABCToolBox). If you are going to use ABCreg to directly make inference from our software please cite the publication","category":"page"},{"location":"#Docker-installation","page":"Home","title":"Docker installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Docker image is based on Debian and includes all the software needed to run the pipeline. You can access Julia or Jupyter pulling the image from Docker Hub or build yourself using the Dockerfile on github. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"By default the Docker image will use any available CPU thread in your machine. Please, remember to use julia -t to use multiple threads and parallelize the estimation. To save the results, you can link the folder /mktest with any folder in your ${HOME} directory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MYPATH=\"/home/jmurga/temporal_mktest/\"\n# Pull the image\ndocker pull jmurga/mktest\n\n# Runninh temporal docker container linking some local volume to export data. Consider to create a container.\ndocker run -it -v --rm ${MYPATH}:/mktest/folder jmurga/mktest abcmk_cli.jl\n# Using -t 8 to parallelize using 8 threads\n# Using -J mktest.so to avoid loading package latency\ndocker run -it -v --rm ${MYPATH}:/mktest/folder jmurga/mktest julia -J mktest.so -t8 abcmk_cli.jl\n\n# Run jupyter notebook from docker image. Change the port if 8888 is already used\ndocker run -it --rm -v ${MYPATH}:/mktest/folder -p 8888:8888 jmurga/mktest /bin/bash -c \"jupyter-lab --ip='*' --port=8888 --no-browser --allow-root\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use our command-line interface, just run","category":"page"},{"location":"","page":"Home","title":"Home","text":"docker run --rm -it -v ${MYPATH}:/mktest/ jmurga/mktest","category":"page"},{"location":"#Singularity-installation","page":"Home","title":"Singularity installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Docker image is based on Debian and includes all the software needed to run the pipeline. You can access Julia pulling the image from Sylabs Cloud Library. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"singularity pull mktest.sif library://jmurga/default/mktest\n\nsingularity run mktest.sif julia ulia -J mktest.so -t8 abcmk_cli.jl","category":"page"}]
}
