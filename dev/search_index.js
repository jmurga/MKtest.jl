var documenterSearchIndex = {"docs":
[{"location":"rates/#Estimating-fixation-and-polymorphic-rates-considering-generalized-model-of-selection-and-linkage","page":"Rates","title":"Estimating fixation and polymorphic rates considering generalized model of selection and linkage","text":"","category":"section"},{"location":"rates/","page":"Rates","title":"Rates","text":"Before executing the rate estimation, start-up Julia using -t option to add the desired number of threads to parallelize the estimation","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"julia -t8","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"using MKtest","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Declare a variable containing some basic information about your model. We used a sample size of 661 to perform later analysis over TGP data. The selected Derived Alleles Counts (DAC) will be used to compute summary statistics and perform ABC inference. It is possible to subset any of the selected DAC values when computing summary statistics. If you want to exclude any variant bellow or above a frequency threshold you can use the argument cutoff.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Note that MKtest.parameters contains information about mutation rate, recombination rate, DFE, BGS and probabilities of fixations. To check all the arguments you can access to the function documentation using @doc MKtest.parameter","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@doc MKtest.parameters\n  Mutable structure containing the variables required to solve the analytical\n  approach. All the functions are solve using the internal values of the structure.\n  You should declare a mutable structure to the perform the analytical estimations.\n\n  Parameters\n  ≡≡≡≡≡≡≡≡≡≡≡≡\n\n    •  gam_flanking::Int64: Selection coefficient for deleterious alleles\n\n    •  gL::Int64: Selection coefficient for weakly benefical alleles\n\n    •  gH::Int64: Selection coefficient for strongly benefical alleles\n\n    •  al_low::Float64: Proportion of α due to weak selection\n\n    •  al_tot::Float64: α\n\n    •  θ_flanking::Float64: Mutation rate defining BGS strength\n\n    •  θ_coding::Float64: Mutation rate on coding region\n\n    •  al::Float64: DFE shape parameter\n\n    •  be::Float64: DFE scale parameter\n\n    •  B::Float64: BGS strength\n\n    •  B_bins::Array{Float64,1}: BGS values to simulate\n\n    •  ppos_l::Float64: Fixation probabily of weakly beneficial alleles\n\n    •  ppos_h::Float64: Fixation probabily of strongly beneficial alleles\n\n    •  N::Int64: Population size\n\n    •  n::Int64: Sample size\n\n    •  Lf::Int64: Flanking region length\n\n    •  ρ::Float64: Recombination rate\n\n    •  TE::Float64\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"We will estimate the empirical adaptation rate using TGP data using the estimated DFE parameters at Boyko et al (2008). Nonetheless, shape and scale DFE parameters are flexible in our model.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"adap = MKtest.parameters(N=10000,n=661,dac=[1,2,4,5,10,20,50,100,200,400,500,661,925,1000],gam_dfe=-457,shape=0.184)","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Now the variable adap contains sample size, DAC and DFE information. The function MKtest.rates will perform the analytical estimation of N independent models regarding DFE, BGS, mutation rate, and recombination rate. In the following example, we used the function MKtest.rates to input the prior distributions. The function will randomize the input values to solve N independent estimation regarding our model. ","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"  rates(param,gH,gL,gam_flanking,gam_dfe,alpha,iterations,output)\n\n  Function to solve randomly N scenarios. The function will create N models,\n  defined by MKtest.parameters(), to solve analytically fixation rates and the\n  expected SFS for each model. The rates will be used to compute summary statistics\n  required at ABC inference. The function output a HDF5 file containing the solved\n  models, the selected DAC and the analytical solutions.\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡≡≡\n\n    •  param::parameters: mutable structure containing the model.\n\n    •  gH::Array{Int64,1}: Range of strong selection coefficients.\n\n    •  gL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients.\n\n    •  gam_flanking::Array{Int64,1}: Range of deleterious selection coefficients at the flanking region.\n\n    •  gam_dfe::Array{Int64,1}: Range of deleterious selection coefficients at the coding region.\n\n    •  alpha::Vector{Float64}: Range of α value to solve\n\n    •  iterations::Int64: Number of solutions.\n\n    •  output::String: File to output HDF5 file.\n\n  Returns\n  ≡≡≡≡≡≡≡≡≡\n\n    •  DataFrame: models solved.\n\n    •  Output: HDF5 file containing models solved and rates.\n\n","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"@time df = MKtest.rates(adap,gH=[200,2000],gL=[1,10],gam_dfe=[-2000,-200],gam_flanking=[-1000,-500],iterations = 10^5,output=\"analysis/rates.jld2\");","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The function will create a HDF5 file containing the solved models, fixation rates, polymorphic rates, and the selected DAC. This information will be used later to estimate summary statistics.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"Note that MKtest.rates is the most resource and time-consuming function. In our case, the function will estimate 10^5 independent models. Each model solves the estimation for all possible BGS values. We used BGS values from 0.1 to 0.999 in 5% increments (defined at adap.B_range). In total, the example will produce 3.7 million estimates. We have used a hierarchical data structure (HDF5) to facilitate model parameters and rates storage.","category":"page"},{"location":"rates/","page":"Rates","title":"Rates","text":"The following example took about 1.5 hours to execute on the hardware described at section Infering the rate and strength of adaptation","category":"page"},{"location":"analytical/#MKtest-estimation","page":"Analytical estimations","title":"MKtest estimation","text":"","category":"section"},{"location":"analytical/#Solving-\\alpha_{(x)}","page":"Analytical estimations","title":"Solving alpha_(x)","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Our method is based on the analytical solution of alpha_(x) given a genetic scenario. The approach could be extended to any DFE and background selection values to get summary statistics used at ABC methods. This example shows how the asymptotic alpha is affected by linkage and background selection.","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Before starting, you need to set up a variable of type MKtest.parameters. It is a Mutable structure containing the parameters required to solve the analytical approach. Any value at MKtest.parameters can be easily changed. Remember, you need to define it before the execution. Otherwise, alpha_(x) will be solved with default values. To change any values, check the variables at the struct MKtest.parameters to set specific models.","category":"page"},{"location":"analytical/#Load-the-modules","page":"Analytical estimations","title":"Load the modules","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"using MKtest","category":"page"},{"location":"analytical/#Setting-model-parameters-and-convolute-the-binomial-distribution.","page":"Analytical estimations","title":"Setting model parameters and convolute the binomial distribution.","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"We set a global adaptation rate of 0.4 with a contribution of 0.2 regarding weak adaptation. The process is modeled using a selection coefficient of 500, 10 for strongly and weakly beneficial alleles. We modeled the DFE for deleterious alleles using the values provided at Boyko et al. (2008).","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"adap = MKtest.parameters(n=661,al_tot=0.4,al_low=0.2,gH=500,gam_dfe=-457,gam_flanking=-1000,shape=0.184,B=0.999)","category":"page"},{"location":"analytical/#Solving-the-model","page":"Analytical estimations","title":"Solving the model","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Here we solve alpha_(x) generally, using the expected rates. We are not considering any specific mutation process over a locus and branch time. We used the fixation and polymorphic rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be cancelled","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"x,y = MKtest.analytical_alpha(adap)","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"Internally the function (1) sets the mutation rate regarding the BGS strength and (2) sets the probability of fixations given the genetic scenario. Then, it estimates the SFS and fixations rates for neutral and non-neutral alleles. Please check MKtest.analytical_alpha to check the process.","category":"page"},{"location":"analytical/#Plotting-the-results.","page":"Analytical estimations","title":"Plotting the results.","text":"","category":"section"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"The variable x contains alpha_(x) accounting for weakly beneficial alleles. y contains the value of alpha_(x), not accounting for weakly beneficial alleles. In this example, we do not model BGS (check B parameter in MKtest.parameters above)","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"In Julia, you can easily use R using the module RCall. Please check you have installed R in your system. Nonetheless, you can plot using the Julia Plots module.","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"If you are using our Docker or Singularity image, you don't need to install anything. Otherwise, install RCall just in case you want to plot using R","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"using Pkg\nPkg.add(\"RCall\")","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"using RCall\n\nR\"\"\"\n\tlibrary(ggplot2)\n\tlibrary(data.table)\n\tdf = data.table(f=seq(1,length($x)),x=$x,y=$y)\n\td  = melt(df,id.vars='f')\n\tp = ggplot(d,aes(x=f,y=value,color=variable)) + geom_line() + geom_point() + scale_colour_manual(values=c('#30504f', '#ab2710'),labels = c(\"Neutral + deleterious alleles\", \"All alleles\")) + theme_bw()\n\tp\n\"\"\"","category":"page"},{"location":"analytical/","page":"Analytical estimations","title":"Analytical estimations","text":"(Image: image)","category":"page"},{"location":"data/#Parsing-genomic-data","page":"Processing data","title":"Parsing genomic data","text":"","category":"section"},{"location":"data/","page":"Processing data","title":"Processing data","text":"The module includes functions to parse TGP from Uricchio et al. (2019) and DGN from Murga-Moreno et al. (2019).","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"Please to parse raw data into SFS and divergence counts, first download raw files deposited in our repository:  ","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"TGP\nDGN Zambia population  \nDGN Raleigh population  ","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"mkdir(\"analysis/\")\ndownload(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/tgp.txt\",\"analysis/tgp.txt\")","category":"page"},{"location":"data/#Parsing-TGP-and-DGN-data-manually","page":"Processing data","title":"Parsing TGP and DGN data manually","text":"","category":"section"},{"location":"data/","page":"Processing data","title":"Processing data","text":"Once you have downloaded the files, you can use the function MKtest.parse_sfs to convert the data into SFS and divergence counts. Please check MKtest.parse_sfs to get more info or execute:","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"It is possible to directly subset genes IDs using the same ids deposited at you data. You can use a (column list file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembllist.txt] or (CSV-like file)[https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/testnonVIPs.txt] to subset the file list. If you use CSV-like each row will be parsed independtly.","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/master/data/ensembl_list.txt\",\"analysis/ensembl_list.txt\")\n\nalpha, sfs, divergence = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/ensembl_list.txt\")","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/example_bootstrap.txt\",\"analysis/example_bootstrap.txt\")\n\n# In our case, eachrow is a bootstrapped set\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\",gene_list = \"analysis/example_bootstrap.txt\")","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"If you are going to parse DGN, you need to change the value of the argument isoline to true. Following the Murga-Moreno et al. (2019) sample size for each population is:","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"Zambia population: 154\nRAL population: 160","category":"page"},{"location":"data/","page":"Processing data","title":"Processing data","text":"download(\"https://raw.githubusercontent.com/jmurga/MKtest.jl/main/data/dgn_ral.txt\",\"analysis/dgn_ral.txt\")\nadap = MKtest.parameters(n=160,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m = MKtest.parse_sfs(adap, data = \"analysis/dgn_ral.txt\",isolines=true)","category":"page"},{"location":"input/#Input-data","page":"Input data","title":"Input data","text":"","category":"section"},{"location":"input/","page":"Input data","title":"Input data","text":"To estimate summary statistics, you need to provide empirical SFS and divergence files. As explained in section data, you can directly parse TGP or DGN data using our module. Nonetheless, you can input any other SFS and divergence file.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"You can easily use Julia to download the files using Julia or Bash. You also can download the files manually.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"Once you have estimated the analytical rates and parsed the SFS and divergence information into variables, you can estimate the summary statistics.","category":"page"},{"location":"input/","page":"Input data","title":"Input data","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")","category":"page"},{"location":"empirical/#Infering-the-rate-and-strength-of-adaptation","page":"Empirical estimation","title":"Infering the rate and strength of adaptation","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We develop an extension of the analytical approximation presented in Uricchio, Petrov, and Enard (2019). In the previous paper, analytical calculations were used to explore the effect of BGS on weakly beneficial alleles, but the estimation procedure employed was based on computationally intensive simulations. While inference procedures based on forward simulations allow for the inclusion of complex demographic histories, they often require high-performance computing resources and can be prohibitively slow for some models. Here we extend Uricchio, Petrov and Enard (2019) analytical approximations to develop a simple and computationally efficient ABC-based inference procedure. Our method accounts for the DFE of deleterious and beneficial alleles and incomplete recombination between selected genomic elements. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"To perform the empirical estimation of alpha_(x) we followed a generic ABC algorithm (Beaumont et al 2002). ABC proceeds by first sampling parameter values from prior distributions, the next simulating model using these parameter values, calculating informative summary statistics, and comparing the simulated summary statistics to the observed data. Considering the standard ABC scheme, we (1) considered N random combinations from prior distributions; (2) solved N independent models to generate informative summary statistics; (3) subset the parameter values producing summary statistics that best match the observed data from an approximate posterior distribution. Additionally, a linear model can be imposed to correct the non-0 distance between the simulated and observed summary statistics.","category":"page"},{"location":"empirical/#Extending-analytical-estimations","page":"Empirical estimation","title":"Extending analytical estimations","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We extended the analytical calculations solving N independents models. We automatize the analytical estimations to input prior distributions. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The models will be solved using random combinations from prior distributions. Fixation, polymorphic rates, and model information will be used to estimate informative summary statistics needed to perform ABC inference. Please see section rates to check how to input prior distributions.","category":"page"},{"location":"empirical/#Summary-statistics","page":"Empirical estimation","title":"Summary statistics","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"\\cite{uricchioexploiting2019} used the analytical theory to demonstrate the effect of weakly beneficial alleles at alpha_(x). To do that, they solved alpha_(x) through the fixation and polymorphism rates since the locus length (L) and the time branch (T) estimations at first order alpha_(x) estimation can be canceled","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbEalpha_(x) approx 1 - fracLT(mathbbEd_S)LT(mathbbEd_N) fracLT(mathbbEp_S(x))LT(mathbbEp_N(x)) approx 1 - fracmathbbEd_SmathbbEd_N fracmathbbEp_S(x)mathbbEp_N(x)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"where fracLTLT with a constant mutation rate tend to 1. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Here, we extended their analytical calculations to generate the summary statistics required at ABC approaches. Thereby we avoided expensive forward simulations. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Considering fixed values of T, L, mu, and fixation rates it is possible to solve analytical alpha_(x) performing the multiplication. However, this requires not only branch length estimations but also explicitly locus length selection which highly increases the order of estimations to solve. To avoid performing branch length estimations in our computation, we assumed that the empirically observed number of fixations should be proportional to the length of the evolutionary branch of interest, T, the locus length L and mutation ration mu. We take the observed total number of fixations (including both nonsynonymous and synonymous sites) as a proxy for the expected number, and then sample weakly deleterious, neutral, and beneficial substitutions proportional to their relative rates for a fixed set of model parameters. The expected number of substitutions for positively selected substitutions is then","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED = X in Poissonleft(lambda = D_observed times (mathbbEd_++mathbbEd_-+mathbbEd_0)right)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"To estimate alpha_(x) we draw the expected values considering each fixation category. We sampled the values in two categories according to the relative rates. Following the same procedure:","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_0mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_N = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_+ + mathbbEd_-mathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"It should be noted that both sampling variance and process variance affect the number of variable alleles at any particular allele frequency in a sequencing sample. ","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"To incorporate that variance we made one sample per frequency-bin given the SFS, we sampled a Poisson distributed number of polymorphic alleles at frequency x relative to their rate given the expected frequency spectra. The expected frequency spectra were downsampled using a binomial (with probability of success given by the frequency beginpmatrix x  2n endpmatrix in a sample of 2n chromosomes) to account for the sampling variance. Considering the random process at each frequency we made credible intervals for future ABC estimations. Otherwise, we would falsely find higher confidence in our parameter estimates. We draw the expected polymorphic values similarly to fixations, considering the SFS and the expected rates.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbEP = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) observed times (mathbbEp_+(x)+mathbbEp_-(x)+mathbbEp_0(x))right)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We modified the expected SFS and the observed SFS considering each frequency x as the cumulative sum above x. This quantities have the same asymptote but are less affected by changing sample size. Therefore, we scaled better the analysis to sample size since most common alleles at frequencies x have very few polymorphic sites in large samples. This way, we finally transformed alpha_(x) to be depending on the previous frequency bin value, which reflects each frequency category over the expected asymptotic shape. Because of that, alpha_(x) analysis is more robust even in low polymorphic populations.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Consequently, for each model combination, it is possible to sample the expected number of fixations and polymorphism to perform the alpha_(x) estimations. Like in Uricchio et al.(2019) we input alpha_(x) as summary statistic at generic ABC algorithm. We exploited summary statistics selection that are informative for estimating alpha_(x) values.","category":"page"},{"location":"empirical/#Parameters-inference","page":"Empirical estimation","title":"Parameters inference","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"We used the expected proportion of weakly and strong fixations to estimate alpha_W, alpha_S and alpha. We followed the same procedure as the above section to subset the expected number of fixation taking into account weakly, strong and deleterious fixation rates categories. Therefore, we modified \\hyperref[eqn 19]{eqn 19} according to their relative fixation rates.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_W = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_WmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"mathbbED_S = X in Poissonleft(lambda = D_observed times leftfracmathbbEd_SmathbbEd_+ + mathbbEd_- + mathbbEd_0rightright)","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"In addition, for each model, we retrieve negative selection coefficients and shape parameter to perform ABC inference.","category":"page"},{"location":"empirical/#Computational-pipeline","page":"Empirical estimation","title":"Computational pipeline","text":"","category":"section"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The following sections describe a pipeline to estimate the empirical adaptation rate (alpha) using whole-genome protein, Viral Interacting Proteins and Non-Viral Interacting Protein data from the TGP. This analysis is similar to the one performed at Uricchio et. al (2019). We divided the pipeline into the following step:","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"MKtest estimations\nEmpirical data parse\nSummary statistic estimation\nABC inference","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Please note that we use a relative path called analysis/ to execute the whole pipeline. This path will be relative to the where Julia or the Command-Line Interface is executed.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The software is prepared to parallelize each pipeline step using Julia Distributed computing. Distributing the process into threads has a cost in RAM. Please make some tests in your machine before executing expensive models. Nonetheless, distributing the estimation into threads decreases the pipeline execution time. It is almost mandatory to parallelize at least the rate estimations.","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"The following examples were tested using a laptop with the following hardware:","category":"page"},{"location":"empirical/","page":"Empirical estimation","title":"Empirical estimation","text":"Intel i7-7700HQ (8) @ 3.800GHz \n16GB RAM DDR4 2400MHz","category":"page"},{"location":"abc/#ABC-inference-from-empirical-data","page":"ABC inference","title":"ABC inference from empirical data","text":"","category":"section"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. Remember you need to install ABCreg before continue. Please check home page to install ABCreg.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"It is possible to perform the inference through Julia. We set the tolerance value such that 2500 acceptances were recorded for the inference","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"posteriors = MKtest.ABCreg(analysis_folder=\"analysis/\",S=size(adap.dac,1),tol=0.025,abcreg=\"/home/jmurga/ABCreg/src/reg\");","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"The function will output one file per dataset containing the posteriors distributions. The posterior distributions contains five columns corresponding to:","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα: Adaptation rate\nγ: Negative selection coefficient\nβ: DFE shape parameter","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"You can check multiple statistics from posteriors distribution using MKtest.summary_abc function. Please check MKtest.summary_abc, you can approximate the inference using different statistics such as the mode, the mean or the median from posterior.","category":"page"},{"location":"abc/","page":"ABC inference","title":"ABC inference","text":"df_summary, parameter_inference = MKtest.summary_abc(posteriors)","category":"page"},{"location":"cli/#Command-Line-Interface","page":"Command-Line interface","title":"Command-Line Interface","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We develop a Command-Line Interface (CLI) in case you want to avoid Julia interpreter. You can easly download abcmk_cli.jl. The CLI have different functions to perform the whole pipeline as explained in Infering the rate and strength of adaptation section","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl  ","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"See --help of each command for usages  \n  rates  \n  summaries  \n  abc","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To reproduce the examples you can follow the steps described at Empirical estimation section","category":"page"},{"location":"cli/#Estimate-rates","page":"Command-Line interface","title":"Estimate rates","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To perform the rate estimations you can use the function rates at the CLI. The function works simirarly to the function MKtest.rates. You can check the argument at Rates sectino or using the macro @doc MKtest.rates in the Julia interpreter.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abcmk_cli.jl rates --help\nFunction to solve analytical fixation rates and the expected SFS. The function will create N random models from prior values. Use the arguments to defined the input range for each parameter.\n\nIf rho and/or theta are not set, default values will be used (0.001).\n\nTo parallelize the estimations please be sure you start up Julia using –threads/-t option and set the number of cores.\n\nThe function returns a HDF5 file containing models solved and rates. The rates will be used to compute summary statistics required at ABC.\n\nPlease check the documentation to get more info about models parameters or detailed arguments description https://jmurga.github.io/MKtest.jl/dev/cli/ to check model\n\nPositional Arguments:\n  N: Int64\n  samples: Int64\n  iterations: Int64\n\nOptional Arguments:\n  --alpha: String (default: 0.1,0.9)\n  --gam-dfe: String (default: -1000,-200)\n  --gam-flanking: String (default: -1000,-500)\n  --gL: String (default: 5,10)\n  --gH: String (default: 400,1000)\n  --dac: String (default: 1,2,4,5,10,20,50,100,200,400,500,661,925,1000)\n  --shape: Float64 (default: 0.184)\n  --rho: Float64 (default: 0.001)\n  --theta: Float64 (default: 0.001)\n  --cutoff: String (default: 0.0,1.0)\n  --output: String (default: rates.jld2)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abcmk_cli.jl rates 10000 661 100000 --alpha 0.1,0.9 --gam-dfe -1000,-200 --gam-flanking -1000,-500 --gL 1,10 --gH 200,2000 --output analysis/rates_cli.jld2","category":"page"},{"location":"cli/#Estimate-summary-statistics","page":"Command-Line interface","title":"Estimate summary statistics","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"To estimate summary statistics, we used the estimated analytical rates and empirical data following the description at section Empirical estimation.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli summaries --help\nEstimate summary statistics using observed data and analytical rates.\n\nPositional Arguments:\n  N: Int64\n  samples: Int64\n  data: String\n\nOptional Arguments:\n  --genes: String (default: <genes.txt>)\n  --dac: String (default: 2,4,5,10,20,50,200,661,925)\n  --cutoff: String (default: 0.0,1.0)\n  --rates: String (default: rates.jld2)\n  --folder: String (default: <folder>)\n  --summsize: Int64 (default: 100000)","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl summaries --folder analysis/ --rates analysis/rates.jld2 --samples 661 --dac 2,4,5,10,20,50,200,661,925 --summsize 1000000","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"The function will output observed data (alphas_N.txt) and summary statistics (summaries_N.txt) in the selected folder. These file will be used at ABC inference to generate posterior distributions.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl summaries --analysis_folder analysis/ --rates  analysis/rates.jld2 --samples 661 --replicas 100 --summstatSize 100000 --dac 2,4,5,10,20,50,200,661,925","category":"page"},{"location":"cli/#Perform-ABC-inference","page":"Command-Line interface","title":"Perform ABC inference","text":"","category":"section"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"At this point, you have a folder containing summary statistics and observed data to perform ABC inference. As explained in our home page, we performed the ABC inference using ABCreg. However, you can used other ABC software to perform the inference.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"We link ABCreg with Julia to perform ABC inference. If you are going to use ABCreg to make inferences from our software directly, please cite the publication. Remember you need to install ABCreg before continue. Please check home page to install ABCreg.","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"It is possible to perform the inference through Julia. The function will output one file per bootstrapped replicas containing the posteriors distributions. We set the tolerance value to record 1000 values for the regression.  The posterior distributions contains five columns corresponding to:","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"α weak: Contribution of weak selecction to alpha\nα strong: Contribution of strong selecction to alpha\nα weak: Adaptation rate\nγ: Negative selection coefficient\nβ: Negative selection coefficient","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia abcmk_cli.jl abc --help\n\nPositional Arguments:\n  nsumm: Int64\n  tol: Float64\n\nOptional Arguments:\n  --folder: String (default: <folder>)\n  --abcreg: String (default: reg)\n","category":"page"},{"location":"cli/","page":"Command-Line interface","title":"Command-Line interface","text":"julia -t8 abc 9 0.025 --folder analysis/ --S 9 --abcreg /home/jmurga/ABCreg/src/reg","category":"page"},{"location":"mk/#MK-approaches","page":"MK approaches","title":"MK approaches","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"We included other heuristic MK approaches in our module. All the functions use the formated SFS and divergence data described at data section.","category":"page"},{"location":"mk/#Standard-MKT","page":"MK approaches","title":"Standard MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The standard McDonald & Kreitman test ([McDonald and Kreitman, 1991]) was developed to be applied to protein coding sequences, combining both divergence (D) and polymorphism (P) sites, and categorizing mutations as synonymous (P_S, D_S) and non-synonymous (P_N, D_N). ","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"If all mutations are either strongly deleterious or neutral, then DiD0 is expected to roughly equal PiP0. In contrast, if positive selection is operating in the region, adaptive mutations rapidly reach fixation and contribute more to divergence than polymorphism compared to neutral mutations, and then DiD0  PiP0. Assuming that adaptive mutations contribute little to polymorphism but substantially to divergence, the proportion of non-synonymous substitutions is inferred following Smith and Eyre-Walker (2002).","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_NP_ScdotfracD_SD_N)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.standardMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"adap = MKtest.parameters(n=661,cutoff=[0.0,1.0])\nalpha, sfs, divergence, m= MKtest.parse_sfs(adap, data = \"analysis/tgp.txt\")\n\nmk = MKtest.standardMK(sfs[1],divergence[1])","category":"page"},{"location":"mk/#Fay,-Waycoff-and-Wu-MK-extension","page":"MK approaches","title":"Fay, Waycoff and Wu MK extension","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Fay et al. (2002) proposed an approach that removes all polymorphisms segregating at a frequency (j) below a given threshold (usually j  515). Although there is no consensus about what this threshold should be used, J. Charlesworth & Eyre-Walker (2008) demonstrated that  estimates are robust using a frequency threshold of 15%, below which most slightly deleterious polymorphisms are found and removed. The estimates are reasonably accurate only when the rate of adaptive evolution is high and the Distribution of Fitness Effects (DFE) of deleterious mutations is leptokurtic.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha = 1 - (fracP_N (j15)P_S (j15)cdotfracD_SD_N)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.fwwMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"fww = MKtest.fwwMK(adap,sfs[1],divergence[1],cutoff=0.15)","category":"page"},{"location":"mk/#imputed-MKT-(in-preparation)","page":"MK approaches","title":"imputed MKT (in preparation)","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The imputed MKT (impMKT) is a modification of the Fay, Waycoff, and Wu MK extension (fwwMK) (Fay et al. (2002) to improve gene-by-gene analyses. The method propose the imputation of slightly deleterious mutations at the SFS rather than removing all variants below a frequency threshold. The imputedMK aims to maximize the information to test the excess of divergence ratio relative to polymorphism at the gene level.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_imputed = 1 - left( fracP_N - P_wdP_S cdot fracD_ND_S right)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"where P_wd is","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"P_wd approx P_wd (j  15) = P_N (j15) - fracP_N (j15)  cdot P_S (j15)P_S (j15)","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.imputedMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"imputed = MKtest.imputedMK(adap,sfs[1],divergence[1],cutoff=0.15)","category":"page"},{"location":"mk/#Asymptotic-MKT","page":"MK approaches","title":"Asymptotic MKT","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Proposed by Messer and Petrov (2013). This extension is robust to the presence of selective sweeps (genetic hitchhiking) and the segregation of slightly deleterious polymorphisms substitutions (BGS). In this approach, the authors defined alpha as a function that depends on the SFS of alleles. Therefore, alpha is estimated in different frequency intervals (x), and these values are then adjusted to an exponential function. An exponential fit is suitable as the non-synonymous allele frequency is expected to decay exponentially over the respective levels of synonymous polymorphisms (Messer & Petrov, 2013).","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"alpha_fit(x) = a+b cdot e^-cx","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Please check MKtest.aMK to obtain more info.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"amk, ci, model = MKtest.aMK(adap,alpha[1])","category":"page"},{"location":"mk/#Grapes","page":"MK approaches","title":"Grapes","text":"","category":"section"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Grapes is a software ML models of the DFE that assume PRF framework can estimate the expected proportion of adaptive fixations given the inferred DFE from the MKT data. In such approaches, the expected levels of fixations and polymorphism are used to perform likelihood estimates, while considering different evolutionary models. ML estimations of the DFE have varied from the first models inferring constant selection parameters across all loci to including models with continuous distributions of both positive and negative selection coefficients \\citep{biernegenomic2004, eyre-walkerdistribution2006, boykoassessing2008, eyre-walkerestimating2009, galtieradaptive2016, racimoapproximation2014, galtieradaptive2016, tataruinference2017, zhengreater2021}, correcting the aforementioned assumptions to calculate how many non-adaptive substitutions are expected to become fixed given the empirical DFE. ","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Notwithstanding, the newest and more sophisticated ML implementations \\citep{galtieradaptive2016, tataruinference2017} take advantage of that proposed by \\cite{eyre-walkerdistribution2006} and \\cite{eyre-walkerestimating2009}, which assumes that non-neutral deleterious mutations arise from a DFE in the form of a Gamma distribution. Nonetheless, unlike \\cite{eyre-walkerdistribution2006}, these methods also model the effect of weakly advantageous alleles through an exponentially distributed function, where DFE is a mixture distribution between the gamma and exponential distributions. Therefore, the state-of-the-art methods usually follow a standard population genetic model based on PRF presented in \\cite{galtieradaptive2016} and \\cite{tataruinference2017} to later perform ML of the DFE. ","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"To estimate the expected counts of polymorphism and divergence, the model considers a Wright-Fisher panmictic population of size N_e, which diverged in a time t where mutation occurs at a mutation rate mu, per site per generation \\citep{galtieradaptive2016}. Figure \\ref{fig:dfeprf} illustrate the equations defining the expected polymorphic and divergence counts. Let consider synonymous mutation as neutral (PS) and non-synonymous mutation as selected (P_N) from PRF the expected counts given a frequency i is estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prfps} \t\\mathbf{E}[P{S[i]}] = \\frac{4Ne \\mu LS}{i} \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prfpn} \t\\mathbf{E}[P{N[i]}] = 4Ne \\mu LN \\int_{0}^{1} B(i,n,x) H(s,x)dx \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\noindent where L_N and L_S are the total number of synonymous and nonsynonymous sampled alleles, B(inx) is the probability of observing a mutation at frequency i in n sequences when the true allele frequency is x","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prf_binom} \tB(i,n,x) = \\begin{pmatrix} n \\ i \\end{pmatrix} x^{i} (1-x)^{n-i} \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\noindent and H(sx) is the time that a new semi dominant mutation with selection coefficient s (in the heterozygous) spends between the frequency x and the frequency x+dx from diffusion theory \\citep{wrightdistribution1938}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prf_stationary} \tH(s,x) = \\frac{1-e^{-s(1-x)}}{x(1-x)(1-e^{-s})} \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Note that to obtain the expected polymorphic count given the underlying DFE of new mutations equation \\eqref{prfpn} should be integrated over the full DFE. Following \\citep{eyre-walkerestimating_2009}, the underlying DFE for new deleterious mutations is defined by expression phi","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prf_gamma} \t\\phi(s;a,b) = a^b s^{b-1} \\frac{e^{-a s}}{\\Gamma(b)} \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\noindent where a and b are scale and shape parameters from the Gamma distribution. Therefore, the expected polymorphic count given a particular DFE is defined as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prftotalpn} \t\\mathbf{E}[P{N[i]}] = 2 Ne \\mu LN \\int{-\\infty}^{\\infty}\\int_{0}^{1}B(i,n,x)H(s,x)\\phi(s;\\alpha,\\beta) dx ds \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"In addition, the method proposed by \\cite{galtieradaptive2016} makes the DFE more flexible by considering that the most appropriate way to model the full DFE may not be the classical Gamma distribution over negative alleles. Therefore, Galtier's modeling included two different versions of the Fisher's geometric model, and a model assuming a Beta-shaped distribution of weak effect mutations, instead of a Gamma distribution. However, as explored further in \\cite{galtieradaptive2016}, \\cite{galtierhow2020} and \\cite{rousselleis2020}, the shifted negative modeling and the two DFE models based on the Fisher geometric model generally do not perform well in the analysis.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Following \\cite{galtieradaptive2016} and \\cite{tataruinference2017} procedure, the expected number of synonymous (D_S) and non-synonymous (D_N) substitutions can be estimated as","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prfds} \tDS = L_S \\mu t \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prfdn} \t\\mathbf{E}[DN] = 2 Ne \\mu LN \\int{-\\infty}^{\\infty} \\frac{2s}{1-e^{(-4 Ne s)}} \\phi(s) ds \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"The proportion of adaptive mutations (alpha) is estimated using the ML inference of DFE parameters and the expected counts of non-adaptive mutations. alpha therefore is estimated subtracting the non-adaptive substitutions and neutral substitutions from the total observed divergence counts at selected sites.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prfadaptive1} \t\\alpha = (dN - d{N}^{na}) / d_N) \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\noindent note that d_N^na is defined following \\cite{galtieradaptive2016}. The equation decomposition is similar to the equations shown at \\cite{tataruinference2017} and \\cite{eyre-walkerestimating2009}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{equation}\\label{prfadaptive2} \td{N}^{na} = \\frac{2LN Ne \\mu \\int{-\\infty}^{s{adv}} \\frac{2s}{1-e^{(-4 Ne s)}} \\phi(s) ds}{LN} \\end{equation}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"To estimate the non-adaptive substitutions, the approach proposed by \\cite{eyre-walkerestimating2009} and \\cite{tataruinference2017} integrate the DFE from -infty to 0 (s_adv = 0), taking into account the deleterious fixations and the negative nearly neutral fixations given the DFE. \\cite{galtieradaptive2016} considers positive s_adv values to subtract nearly neutral positive fixations given the s_adv threshold too.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\begin{figure}[h] \t\\includegraphics[width=1\\textwidth]{\\dir/introduction/figures/dfeprf.pdf} \t\\caption[Expected polymorphic and divergence sites based on PRF]{Expected polymorphic and divergence sites based on PRF approach. Note that for s=0 the equations became similar to equations \\eqref{prfps} and \\eqref{prfds}. Adapted from \\cite{casillasmolecular2017}.} \t\\label{fig:dfeprf} \\end{figure}","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"It is important to emphasize that the shape of the SFS may be biased and differ from the previously expected values. The distortion may mainly be due to the effect of demographic events. To account for such distortions, the different methods usually incorporate nuisance parameters following \\citep{eyre-walkerdistribution2006}. The nuisance parameter r modifies each frequency of the SFS individually. Thus, r modifies the effective mutation rate at each frequency i, considering the relative mutation rate at i with respect to the mutation rate at singletons \\cite{eyre-walkerdistribution2006}. The perturbing parameter r_i considers the same amount of distortion between nonsynonymous and synonymous SFS. Although the assumption is unrealistic, simulations showed that the original correction proposed by \\cite{eyre-walkerdistribution2006} is robust enough to take into account demographic effects. However, other models correct for demographic effects by considering explicit changes in the effective population during the modeling process \\citep{eyre-walkerestimating2009,zhengreater2021}.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"Despite the efforts for modeling the DFE using polymorphic data, \\cite{bookerinferring2020} suggested that inferred parameters from ML approaches must be reviewed. Underlying assumptions regarding the DFE shape, selection coefficient strengths, or population sizes can affect the estimations and capture distinct aspects of the DFE \\citep{bookerinferring2020,zhengreater2021}. Such a situation is plausible in several \\textit{D. melanogaster} studies. For example, \\cite{camposestimating2017} and \\cite{keightleyinferring2016} found differences between selection coefficients and probabilities of beneficial alleles. As extensively discussed in \\cite{bookerinferring2020}, it is plausible due to different methodological assumptions or if the DFE for advantageous mutations is bimodal. This latter case should be especially considered for strongly beneficial alleles, which would be undetectable by analyzing the unfolded SFS (uSFS) \\citep{bookerinferring2020}.","category":"page"},{"location":"mk/","page":"MK approaches","title":"MK approaches","text":"\\cite{messerpopulation2013} compared the performance of their method -the aMKT- and the \\texttt{DFE-alpha} method \\citep{eyre-walkerestimating2009} through simulations. They claimed that DFE-alpha correctly estimated  when the model allowed for population size change, but the demography inferred was found to be biased, mainly due to background selection acting at linked sites. Genetic draft leaves signatures in the SFS similar to those observed under a recent population size expansion. The DFE-alpha method inferred systematically a population expansion even though no expansion was set in the simulation . Another limitation of PRF approaches is that it becomes computationally intensive, especially when a change in demographic model is applied. Since DFE-alpha can only consider two population-size changes, it becomes insufficient for capturing the excess of rare variants due to the complex demo","category":"page"},{"location":"reference/#Model-parameters","page":"Reference","title":"Model parameters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"adap is the only variable exported from MKtest module. It is a Mutable structure contaning the variables required to solve the analytical approach. Any value can be easly changed. Remember adap should be change before the execution, in other case, alpha_(x) will be solve with the default values. To change all the values at once, you can use MKtest.parameters in order to set specific models in a new variable.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parameters\nMKtest.analytical_alpha\nMKtest.assertion_params\nMKtest.Br\nMKtest.set_θ\nMKtest.alpha_exp_sim_low\nMKtest.alpha_exp_sim_tot\nMKtest.solv_eqns\nMKtest.set_ppos\nMKtest.binom_op\nMKtest.Φ\nMKtest.analytical_alpha","category":"page"},{"location":"reference/#MKtest.parameters","page":"Reference","title":"MKtest.parameters","text":"Mutable structure containing the variables required to solve the analytical approach. All the functions are solve using the internal values of the structure. You should declare a mutable structure to the perform the analytical estimations.\n\nParameters\n\ngam_flanking::Int64: Selection coefficient for deleterious alleles\ngL::Int64: Selection coefficient for weakly benefical alleles\ngH::Int64: Selection coefficient for strongly benefical alleles\nal_low::Float64: Proportion of α due to weak selection\nal_tot::Float64: α\nθ_flanking::Float64: Mutation rate defining BGS strength\nθ_coding::Float64: Mutation rate on coding region\nal::Float64: DFE shape parameter \nbe::Float64: DFE scale parameter\nB::Float64: BGS strength\nB_bins::Array{Float64,1}: BGS values to simulate\nppos_l::Float64: Fixation probabily of weakly beneficial alleles\nppos_h::Float64: Fixation probabily of strongly beneficial alleles\nN::Int64: Population size\nn::Int64: Sample size\nLf::Int64: Flanking region length\nρ::Float64: Recombination rate\nTE::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/#MKtest.analytical_alpha","page":"Reference","title":"MKtest.analytical_alpha","text":"analytical_alpha(param)\n\nAnalytical α(x) estimation. Solve α(x) generally. We used the expected fixation rates and SFSto approach the asympotic value accouting for background selection, weakly and strong positive selection. α(x) can be estimated taking into account the role of positive selected alleles or not. In this way we explore the role of linkage to deleterious alleles in the coding region.\n\nmathbbEalpha_x =  1 - left(fracmathbbED_smathbbED_NfracmathbbEP_NmathbbEP_Sright)\n\nArguments\n\nparam::parameters\n\nReturns\n\nTuple{Vector{Float64},Vector{Float64}}: α(x) accounting for weak adaptation, α(x) non-accouting for weak adaptation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Br","page":"Reference","title":"MKtest.Br","text":"Br(Lmax,theta)\n\nExpected reduction in nucleotide diversity. Explored at Charlesworth B., 1994:\n\nfracpipi_0 = e^frac4muL2rL+t\n\nArguments\n\nparam::parameters\ntheta::Float64\n\nReturns\n\nFloat64: expected reduction in diversity given a non-coding length, mutation rate and defined recombination.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.binom_op","page":"Reference","title":"MKtest.binom_op","text":"binom_op(param)\n\nBinomial convolution to sample the allele frequencies probabilites depending on background selection values and sample size.\n\nArguments\n\nparam::parameters\nbinom::binomialDict\n\nReturns\n\nArray{Float64,2}: convoluted SFS for each B value defined in the model (param.B_bins). The estimations are saved at convolutedBn.bn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.Φ","page":"Reference","title":"MKtest.Φ","text":"Φ(param,s)\n\nReduction in fixation probabilty due to background selection and linkage. The formulas used have been subjected to several theoretical works (Charlesworth B., 1994, Hudson et al., 1995, Nordborg et al. 1995, Barton NH., 1995).\n\nThe fixation probabilty of selected alleles are reduce by a factor phi:\n\nphi(ts) = e^frac-2mut(1+fracrLt+frac2st)\n\nMultiplying across all deleterious linkes sites, we find:\n\nPhi = prod_1^L = phi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nphi(ts) = e^frac-2tmu(psi1fracr+2s+Lr - psi1fracr(L+1)+2s+tr)r^2\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\ngamma::Int64: selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest-estimation","page":"Reference","title":"MKtest estimation","text":"","category":"section"},{"location":"reference/#Fixations","page":"Reference","title":"Fixations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.fix_neut\nMKtest.fix_neg_b\nMKtest.p_fix\nMKtest.fix_pos_sim","category":"page"},{"location":"reference/#MKtest.fix_neut","page":"Reference","title":"MKtest.fix_neut","text":"fix_neut(parameters)\n\nExpected neutral fixations rate reduce by B value.\n\nmathbbED_s = (1 - p_- - p_+) B frac12N\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\n\nReturns\n\nFloat64: expected rate of neutral fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.p_fix","page":"Reference","title":"MKtest.p_fix","text":"p_fix(parameters,gam)\n\nExpected positive fixation rate.\n\nmathbbED_n+ =  p_+ cdot B cdot (1 - e^(-2s))\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ngam::Int64: positive selection coefficient.\n\nReturns\n\nFloat64: expected rate of positive fixation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fix_pos_sim","page":"Reference","title":"MKtest.fix_pos_sim","text":"fix_pos_sim(parameters,gamma,ppos)\n\nExpected positive fixations rate reduced due to the impact of background selection and linkage. The probabilty of fixation of positively selected alleles is reduced by a factor Φ across all deleterious linked sites Analytical.Φ.\n\nmathbbED_n+ =  Phi cdot mathbbED_n+\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ngam::Int64: positive selection coefficient.\nppos::Float64: positive selected alleles probabilty.\n\nReturns\n\nFloat64: expected rate of positive fixations under background selection\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polymorphism","page":"Reference","title":"Polymorphism","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.sfs_neut\nMKtest.sfs_pos\nMKtest.sfs_pos_float\nMKtest.sfs_neg\nMKtest.cumulative_sfs\nMKtest.reduce_sfs","category":"page"},{"location":"reference/#MKtest.sfs_neut","page":"Reference","title":"MKtest.sfs_neut","text":"sfs_neut(param,binom)\n\nExpected rate of neutral allele frequency reduce by backgrou\tnd selection. The spectrum depends on the number of individual []\n\nmathbbEPs_(x) = sumx^*=xx^*=1f_B(x)\n\nInput\n\nparam::parameters: mutable structure containing the model.\nSparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nVector{Float64}: expected rate of neutral alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_pos","page":"Reference","title":"MKtest.sfs_pos","text":"sfs_pos(param,s,p,binom)\n\nExpected rate of positive selected allele frequency reduce by background selection. The spectrum depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model.\ns::Int64: selection coefficient.\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected positive selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sfs_neg","page":"Reference","title":"MKtest.sfs_neg","text":"sfs_neg(param,p,binom)\n\nExpected rate of positive selected allele frequency reduce by background selection. Spectrum drawn on a gamma DFE. It depends on the number of individuals.\n\nArguments\n\nparam::parameters: mutable structure containing the model\np::Float64: positive selected alleles probabilty.\nbinom::SparseMatrixCSC{Float64, Int64}: convoluted SFS given the B value.\n\nReturn:\n\nArray{Float64}: expected negative selected alleles frequencies.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.cumulative_sfs","page":"Reference","title":"MKtest.cumulative_sfs","text":"cumulative_sfs(sfs_tmp)\n\nChanging SFS considering all values above a frequency x. The original aMK approach takes Pn(x) and Ps(x) as the number of polymorphic sites at frequency x rather than above x, but this approach scales poorly as sample size increases. We define the polymorphic spectrum as stated above since these quantities trivially have the same asymptote but are less affected by changing sample size.\n\nArguments\n\nsfs_tmp::Union{Array,SubArray}: SFS vector.\nfreqs::Bool: true/false wheter the input SFS vector containing a first columns with the frequencies.\n\nOutput\n\nVector{Float64}: SFS vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.reduce_sfs","page":"Reference","title":"MKtest.reduce_sfs","text":"reduce_sfs(sfs_tmp,bins)\n\nFunction to reduce the SFS into N bins.\n\nArguments\n\nsfs_tmp::Vector{Float64}: SFS vector.\nbins::Int64: bin size to collapse the SFS.\n\nOutput\n\nVector{Float64}: Binned SFS vector.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Rates","page":"Reference","title":"Rates","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.simulate_models\nMKtest.solve_model\nMKtest.solve_rates\nMKtest.rates","category":"page"},{"location":"reference/#MKtest.rates","page":"Reference","title":"MKtest.rates","text":"rates(param,gH,gL,gam_flanking,gam_dfe,alpha,iterations,output)\n\nFunction to solve randomly N scenarios. The function will create N models, defined by MKtest.parameters(), to solve analytically fixation rates and the expected SFS for each model. The rates will be used to compute summary statistics required at ABC inference. The function output a HDF5 file containing the solved models, the selected DAC and the analytical solutions. \n\nArguments\n\nparam::parameters: mutable structure containing the model.\ngH::Array{Int64,1}: Range of strong selection coefficients.\ngL::Union{Array{Int64,1},Nothing}: Range of weak selection coefficients.\ngam_flanking::Array{Int64,1}: Range of deleterious selection coefficients at the flanking region.\ngam_dfe::Array{Int64,1}: Range of deleterious selection coefficients at the coding region.\nalpha::Vector{Float64}: Range of α value to solve.\niterations::Int64: Number of solutions.\noutput::String: File to output HDF5 file.\n\nReturns\n\nDataFrame: models solved.\nOutput: HDF5 file containing models solved and rates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Summary-statistics","page":"Reference","title":"Summary statistics","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.poisson_fixation\nMKtest.poisson_polymorphism\nMKtest.sampling_summaries\nMKtest.summary_statistics\nMKtest.filter_expected\nMKtest.pol_correction","category":"page"},{"location":"reference/#MKtest.poisson_fixation","page":"Reference","title":"MKtest.poisson_fixation","text":"poisson_fixation(observed_values,λds, λdn)\n\nDivergence sampling from Poisson distribution. The expected neutral and selected fixations are subset through their relative expected rates (fix_neut, fix_neg_b, fix_pos_sim). Empirical values are used are used to simulate the locus L along a branch of time T from which the expected Ds and Dn raw count estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily given the success rate lambda in the distribution.\n\nmathbbED_N = X in Poissonleft(lambda = D times leftfracmathbbED_+ + mathbbED_-mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nmathbbED_S = X in Poissonleft(lambda = D times leftfracmathbbED_0mathbbED_+ + mathbbED_- + mathbbED_0rightright)\n\nArguments\n\nobserved_values::Array: Array containing the total observed divergence.\nλds::Float64: expected neutral fixations rate.\nλdn::Float64: expected selected fixations rate.\n\nReturns\n\nArray{Int64,1} containing the expected count of neutral and selected fixations.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.poisson_polymorphism","page":"Reference","title":"MKtest.poisson_polymorphism","text":"poisson_polymorphism(observed_values,λps,λpn)\n\nPolymorphism sampling from Poisson distributions. The total expected neutral and selected polimorphism are subset through the relative expected rates at the frequency spectrum (fix_neut, sfs_neut,). Empirical sfs are used to simulate the locus L along a branch of time T from which the expected Ps and Pn raw count are estimated given the mutation rate (mu). Random number generation is used to subset samples arbitrarily from the whole sfs given each frequency success rate lambda in the distribution.\n\nThe success rate managing the Poisson distribution by the observed count each frequency.  We considered both sampling variance and process variance is affecting the number of variable alleles we sample from SFS. This variance arises from the random mutation-fixation process along the branch. To incorporate this variance we do one sample per frequency-bin and use the total sampled variation and the SFS for the summary statistics.\n\nmathbbEP_N   = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_+(x) + mathbbEP_-(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nmathbbEP_S = sum_x=0^x=1 X in Poissonleft(lambda = SFS_(x) times leftfracmathbbEP_0(x)mathbbEP_+(x) + mathbbEP_-(x) + mathbbEP_0(x)rightright)\n\nArguments\n\nobserved_values::Array{Int64,1}: Array containing the total observed divergence.\nλps::Array{Float64,1}: expected neutral site frequency spectrum rate.\nλpn::Array{Float64,1}: expected selected site frequency spectrum rate.\n\nReturns\n\nArray{Int64,2} containing the expected total count of neutral and selected polymorphism.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.sampling_summaries","page":"Reference","title":"MKtest.sampling_summaries","text":"sampled_alpha(observed_values,λds, λdn)\n\nOuput the expected values from the Poisson sampling process. Please check poisson_fixation and poisson_polymorphism to understand the samplingn process. α(x) is estimated through the expected values of Dn, Ds, Pn and Ps.\n\nArguments\n\nparam::parameters: Array containing the total observed divergence.\nd::Array: observed divergence.\nafs::Array: observed polymorphism.\nλdiv::Array{Float64,2}: expected fixations rate.\nλdiv::Array{Float64,2}: expected site frequency spectrum rates.\n\nReturns\n\nαsummaries,expdn,expds,exppn,exp_ps,ssAlpha\n\nArray{Int64,2} containing α(x) values.\nArray{Int64,1} expected non-synonymous divergence.\nArray{Int64,1} expected synonymous divergence.\nArray{Int64,1} expected non-synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,1} expected synonymous polymorphism.\nArray{Int64,2} containing α(x) binned values.\n\nsampling_summaries(gammaL,gammaH,ppos_l,ppos_h,observedData,nopos)\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_statistics","page":"Reference","title":"MKtest.summary_statistics","text":"summary_statistics(param,h5_file,sfs,divergence,analysis_folder,summstat_size)\n\nEstimate summary statistics using observed data and analytical rates. analysis_folder will check for the SFS and divergence file and will be used to output summary statistics\n\nArguments\n\nparam::parameters : Mutable structure containing the models\nh5_file::String : HDF5 containing solved models, fixation and polymorphic rates\nsfs::Vector: SFS data parsed from parse_sfs().\ndivergence::Vector: divergence data from parse_sfs().\nanalysis_folder::String : path to save summary statistics and observed data.\nsummstat_size::Int64 : number of summary statistics to sample.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Inference-tools","page":"Reference","title":"Inference tools","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.parse_sfs\nMKtest.get_pol_div\nMKtest.data_to_poisson\nMKtest.write_files\nMKtest.ABCreg\nMKtest.get_mode\nMKtest.estimates\nMKtest.summary_abc\nMKtest.bootstrap_data","category":"page"},{"location":"reference/#MKtest.parse_sfs","page":"Reference","title":"MKtest.parse_sfs","text":"parse_sfs(param;data,gene_list,sfs_columns,div_columns,m_columns,bins,isolines)\n\nFunction to parse polymorphism and divergence by subset of genes. The input data is based on supplementary material described at Uricchio et al. 2019. Please be sure the file is tabulated.\n\nGeneId Pn DAF seppareted by commas Ps DAF separated by commas Dn Ds\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\nXXXX 0 ,0,0,0,0,0,0,0,0 0 ,0,0,0,0,0,0,0,0 0 0\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\ndata::S: path to polymorphic and divergence raw data.\ngene_list:S: path to gene list. \nsfs_columns::Vector{Int64}: column numbers corresponding to Pn and Ps frequencies. Default values [3,5]\ndiv_columns::Vector{Int64}: column numbers corresponding to Dn and Ds frequencies. Default values [6,7]\nm_columns::Vector{Int64}: column numbers corresponding to total number of non-synonymous and synonymous sites. Not require at data. Default values [7,8]\nbins::Union{Nothing,Int64}: size to bin the SFS independtly of the sample size.\n\nReturns\n\nVector{Vector{Float64}}: α_x values. Estimated using the cumulative SFS\nVector{Matrix{Float64}}: Site Frequency Spectrum (non-cumulative)\nVector{Matrix{Int64}}: Synonymous and non-synonymous divergence counts\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.ABCreg","page":"Reference","title":"MKtest.ABCreg","text":"ABCreg(analysis_folder, S, P, tol, abcreg)\n\nPerforming ABC inference using ABCreg. Please, be sure the input folder contain the observed and summary statistics produced by MKtest.summary_statistics().\n\nArguments\n\nanalysis_folder::String : folder containing the observed data and summary estatistics. It will be used to output the posterior distributions\nP::Int64 : number of parameters to infer.\nS::Int64 : number of summary stastitics to perform the inference.\ntol::Float64 : tolerance value. It defines the number of accepted values at ABC inference.\nabcreg::String : path to ABCreg binary.\n\nOutput\n\nposteriors:Vector{Matrix{Float64}}: posteriors distributions estimated by ABCreg.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.summary_abc","page":"Reference","title":"MKtest.summary_abc","text":"summary_abc(posteriors,stat)\n\nPosterior distributions statistics. The function estimates Min., 0.5% Perc., Median, Mean, Mode, \"99.5% Perc., Max values. The mode is estimated following R package abc mode function. The argument stat define the output estimation.\n\nArguments\n\nposterior::Matrix{Float64} : posterior distribution.\nstat::String: output estimation.\nplot_path{String,Nothing}: path to save posterior plot.\n\nOutput\n\nDataFrame: posterior statistics.\nDataFrame: chosen statistic inference.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest","page":"Reference","title":"MKtest","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MKtest.aMK\nMKtest.imputedMK\nMKtest.fwwMK\nMKtest.standardMK\nMKtest.grapes","category":"page"},{"location":"reference/#MKtest.aMK","page":"Reference","title":"MKtest.aMK","text":"aMK(param,α;dac_rm,na_rm)\n\nFunction to estimate the asymptotic value of α(x).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model\nα::Matrix{Float64}: α(x) values.\ndac_rm::Bool: Remove any value not selected at param.dac.\nna_rm::Bool: Remove any NA value at α(x)\n\nReturns\n\nTuple{Float64, Vector{Float64}, Vector{Float64}}: Tuple containing aMK estimation, CI estimation, model output.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.imputedMK","page":"Reference","title":"MKtest.imputedMK","text":"imputedMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the imputedMK (https://doi.org/10.1093/g3journal/jkac206).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix{Float64}: SFS data parsed from parse_sfs().\ndivergence::Matrix{Int64}: divergence data from parse_sfs().\ncutoff{Float64}: frequency cutoff to perform imputedMK.\nm::Matrix{Int64}: total number of sites parsed from parse_sfs()\n\nReturns\n\n`Dict: Dictionary containing imputedMK estimation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.fwwMK","page":"Reference","title":"MKtest.fwwMK","text":"fwwMK(param,sfs,divergence;m,cutoff)\n\nFunction to estimate the fwwMK (https://doi.org/10.1038/4151024a).\n\nArguments\n\nparam::parameters: mutable structure containing the variables required to solve the model.\nsfs::Matrix{Float64}: SFS data parsed from parse_sfs().\ndivergence::Matrix{Int64}: divergence data from parse_sfs().\ncutoff{Float64}: frequency cutoff to perform imputedMK.\nm::Matrix{Int64}: total number of sites parsed from parse_sfs()\n\nReturns\n\n`Dict: Dictionary containing imputedMK estimation.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.standardMK","page":"Reference","title":"MKtest.standardMK","text":"standardMK(sfs,divergence;m)\n\nFunction to estimate the original α value.\n\nArguments\n\nsfs::Matrix{Float64}: SFS array\ndivergence::Array: divegence count array\nm::Union{Nothing,Array}: non-synonymous and synonymous sites# Returns\n\nOutput\n\n`Dict: Dictionary containing results\n\n\n\n\n\n","category":"function"},{"location":"reference/#MKtest.grapes","page":"Reference","title":"MKtest.grapes","text":"grapes(sfs,divergence,m,model,folder,bins)\n\nRun grapes using SFS and divergence data. The function will install grapes using Conda from genomedk channel. \n\nArguments\n\nsfs::Vector{Matrix{Float64}}: SFS data parsed from MKtest.parse_sfs()\ndivergence::Vector{Matrix{Int64}}: divergence data parsed from MKtest.parse_sfs()\nm::Vector{Matrix{Int64}}: total number of sites parsed from MKtest.parse_sfs()\nmodel::String: grapes model.\nfolder::String: output folder.\nbins::Int64:  bin size to reduce the SFS. Grapes became unstable when inputing large SFS.\n\nOutput\n\nDataFrame: grapes model estimation.\n\n\n\n\n\n","category":"function"},{"location":"summstat/#Summary-statistics","page":"Summary statistics","title":"Summary statistics","text":"","category":"section"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"To estimate summary statistics, we used the estimated analytical rates and empirical data following the description at section Empirical estimation","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Before executing the rate estimation, start-up Julia using -t option to add the desired number of threads to parallelize the estimation","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"julia -t8","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Before to compute the summary statistic, declare a model specifying the sample size and cutoff used to estimate the rates.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"adap = MKtest.parameters(N=10000,n=661,dac=[2,4,5,10,20,50,200,661,925],cutoff=[0.0,1.0])","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Note you can only input DAC already estimated, nonetheles you can perform any subset from the estimated DAC. To check the estimated DAC you can follow the hierarchy of the h5 variable.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using JLD2\n# Check hierarchy\nh5   = jldopen(\"analysis/rates.jld2\")\nh5\n\nJLDFile /home/jmurga/analysis/rates.jld2 (read-only)\n └─📂 10000\n    └─📂 661\n       └─📂 cutoff=[0.0,1.0]\n          ├─🔢 models\n          ├─🔢 neut\n          ├─🔢 sel\n          ├─🔢 dsdn\n          └─🔢 dac","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"# Checking estimated dac, string pattern inside the HDF5 variable\nh5[\"10000/661/dac\"]\n\n14-element Vector{Int64}:\n    1\n    2\n    4\n    5\n   10\n   20\n   50\n  100\n  200\n  400\n  500\n  661\n  925\n 1000","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function MKtest.summary_statistics use the SFS and divergence Matrix output from MKtest.parse_sfs.","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"@time summstat = MKtest.summary_statistics(param=adap,h5_file=\"analysis/rates.jld2\",sfs=sfs,divergence=divergence,analysis_folder=\"analysis/\",summstat_size=10^5,bootstrap=100);","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"Nonetheless, you can read your SFS and divergence files using the packages CSV and DataFrames to create the input Vectors. In such case, please be sure that sfs and divergence arguments are of type Vector using square braces ([]) comprehesion","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"using CSV, DataFrames\nsfs = CSV.read(\"/path/to/sfs_file.txt\", header=false, DataFrame) |> Matrix\ndivergence = CSV.read(\"/path/to/divergence_file.txt\", header=false, DataFrame) |> Matrix\n\n# Note we modified both variables into a Vector using square braces ([]) comprehesion\n@time summstat = MKtest.summary_statistics(param=adap,h5_file=\"analysis/rates.jld2\",sfs=[sfs],divergence=[divergence],analysis_folder=\"analysis/\",summstat_size=10^5);\n","category":"page"},{"location":"summstat/","page":"Summary statistics","title":"Summary statistics","text":"The function will create N summary statistic files and the observed data files depending on the length of variables sfs and divergence parsed with MKtest.parse_sfs function (summaries_N.txt and alpha_N.txt respectively, see Data). Both files will be used to perform the ABC inference.","category":"page"},{"location":"#MKtest.jl","page":"Home","title":"MKtest.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MKtest.jl is a Julia package containing an extension of a fast Approximate Bayesian Computation version of the McDonald-Kreitman (ABC-MK) presented in Uricchio et al.(2019) that significantly improves the efficiency of the population genetics inferences. Following Uricchio et al.(2019), the analytical calculations were used to explore the effect of background selection and selective interference on weakly beneficial alleles. Nonetheless, we developed a more straightforward and computationally efficient ABC-based inference procedure that accounts for the DFE of deleterious and beneficial alleles and partial recombination between selected genomic elements. Our approach directly estimates alpha, alpha_W, alpha_S, and the Gamma distribution DFE parameters. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, the package automatizes other MK-like analyses parsing polymorphic and divergence data as well as executing several extensions such as Grapes, aMK, imputedMK or fwwMK.","category":"page"},{"location":"#Docker-installation","page":"Home","title":"Docker installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We highly recommend using the Docker image to execute the software. The Docker image is based on Debian and includes all the software needed to run the pipeline. You can access Julia or Jupyter pulling the image from Docker Hub. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please, remember to use julia -t to use multiple threads and parallelize the estimation. Although optional, note that you can run Julia using a pre-compiled image inside docker to avoid package loading latency. To save the results, you can link the folder /analysis with any folder in your ${HOME} directory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"MYPATH=\"/home/jmurga/temporal_analysis/\"\n# Pull the image\ndocker pull jmurga/mktest\n\n# Runninh temporal docker container linking some local volume to export data. Consider to create a container.\n# Using -t 8 to parallelize using 8 threads\n# Using -J mktest.so to avoid loading package latency\ndocker run -it -v --rm ${MYPATH}:/analysis/folder jmurga/mktest julia -t 8 -J mktest.so\n\n# Run jupyter notebook from docker image. Change the port if 8888 is already used\ndocker run -it --rm -v ${MYPATH}:/analysis/folder -p 8888:8888 jmurga/mktest /bin/bash -c \"jupyter-lab --ip='*' --port=8888 --no-browser --allow-root\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use our command-line interface, just run","category":"page"},{"location":"","page":"Home","title":"Home","text":"docker run -it -v ${MYPATH}:/analysis/ jmurga/mktest julia -t 8 -J mktest.so /analysis/abcmk_cli.jl","category":"page"},{"location":"#Singularity-installation","page":"Home","title":"Singularity installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have created a Singularity container to use the software in HPC systems. We have tested the software at HPC working with Slurm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"singularity pull --arch amd64 library://jmurga/default/mktest:latest","category":"page"},{"location":"#Scratch-installation","page":"Home","title":"Scratch installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install our module from scratch, we highly recommend using LTS official Julia binaries. Once you have installed Julia in your system, consider to install some important dependencies to automatize your pipelines. We have prepared a file to install them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"curl -o julia_dependencies.jl https://raw.githubusercontent.com/jmurga/MKtest.jl/master/scripts/julia_dependencies.jl\njulia julia_dependencies.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can easily install our Julia package manually executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia -e 'using Pkg;Pkg.add(PackageSpec(path=\"https://github.com/jmurga/MKtest.jl\"))'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or from Pkg REPL (by pressing ] at Julia interpreter):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/jmurga/MKtest.jl","category":"page"},{"location":"#ABCreg","page":"Home","title":"ABCreg","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We have linked ABCreg with Julia to perform ABC inference. Nonetheless others ABC softwares could be used (like abc (R package) or ABCToolBox). If you are going to use ABCreg to directly make inference from our software please cite the publication and compile it in your system. Anyway, once you get the summary statistic files you can use any other ABC software.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ABCreg needs GSL and libz to work. Please install both libraries before compile the software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Linux debian-based installation\nsudo apt install libgsl-dev libz-dev build-essential git\n# MacOS installation\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nbrew install GSL zlib git","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/molpopgen/ABCreg.git ABCreg\ncd ABCreg/src && make","category":"page"}]
}
